#!/bin/sh

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
TERRAFORM_ROOT="$(cd "$SCRIPT_DIR/../terraform" && pwd)"

# Initialize Terraform in parallel
(terraform -chdir=$TERRAFORM_ROOT/app init) &
(terraform -chdir=$TERRAFORM_ROOT/meta init) &
wait

# Get ECR repo URL, Git SHA, and app name

APP_NAME=$(terraform -chdir=$TERRAFORM_ROOT/app output -raw app_name)
ECR_REPO=$(terraform -chdir=$TERRAFORM_ROOT/app output -raw ecr_repository_url)
GIT_SHA=$(git rev-parse --short HEAD)

# Set AWS credentials if not already set
if [ -z "$AWS_ACCESS_KEY_ID" ]; then
  export AWS_ACCESS_KEY_ID=$(terraform -chdir=$TERRAFORM_ROOT/meta output -raw deployer_access_key_id)
fi

if [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
  export AWS_SECRET_ACCESS_KEY=$(terraform -chdir=$TERRAFORM_ROOT/meta output -raw deployer_secret_access_key) 
fi

# Check if image with Git SHA already exists in ECR
if ! aws ecr describe-images --repository-name $(echo $ECR_REPO | cut -d'/' -f2) --image-ids imageTag=${GIT_SHA} >/dev/null 2>&1; then
  # Login to ECR only if we need to push
  aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com

  # Build and push only if image doesn't exist
  echo "Building and pushing new image ${ECR_REPO}:${GIT_SHA}"
  # Use buildx for faster multi-platform builds
  docker buildx build --platform linux/amd64 --push -t ${ECR_REPO}:${GIT_SHA} -t ${ECR_REPO}:latest .
else
  echo "Image ${ECR_REPO}:${GIT_SHA} already exists, skipping build and push"
fi

# Get current image tag from ECS service
CURRENT_TAG=$(aws ecs describe-services --cluster ${APP_NAME}-cluster --services ${APP_NAME} --query 'services[0].taskDefinition' --output text | rev | cut -d':' -f1 | rev)

# Only deploy if the image tag has changed
if [ "$CURRENT_TAG" != "$GIT_SHA" ]; then
  echo "Deploying new image tag ${GIT_SHA}"
  terraform -chdir=$TERRAFORM_ROOT/app apply -var="image_tag=${GIT_SHA}" -auto-approve

  # Wait for deployment to stabilize
  echo "Waiting for deployment to stabilize..."
  aws ecs wait services-stable --cluster ${APP_NAME}-cluster --services ${APP_NAME}-web

  # Get VPC configuration
  PRIVATE_SUBNET_IDS=$(terraform -chdir=$TERRAFORM_ROOT/app output -json private_subnet_ids | jq -c .)
  APP_SECURITY_GROUP_ID=$(terraform -chdir=$TERRAFORM_ROOT/app output -raw app_security_group_id)

  # Run database migrations
  echo "Running database migrations..."
  TASK_ARN=$(aws ecs run-task \
    --cluster ${APP_NAME}-cluster \
    --task-definition ${APP_NAME}-web \
    --network-configuration "awsvpcConfiguration={subnets=${PRIVATE_SUBNET_IDS},securityGroups=[\"${APP_SECURITY_GROUP_ID}\"],assignPublicIp=DISABLED}" \
    --launch-type FARGATE \
    --overrides '{"containerOverrides": [{"name": "'${APP_NAME}-web'", "command": ["bundle", "exec", "rails", "db:migrate"]}]}' \
    --query 'tasks[0].taskArn' \
    --output text)

  # Wait for migration task to complete and show logs
  echo "Waiting for migration task to complete..."
  aws ecs wait tasks-stopped --cluster ${APP_NAME}-cluster --tasks $TASK_ARN

  # Print the task ARN
  echo "Migration task ARN: $TASK_ARN"

  # Check if the migration task failed
  TASK_STATUS=$(aws ecs describe-tasks --cluster ${APP_NAME}-cluster --tasks $TASK_ARN --query 'tasks[0].containers[0].exitCode' --output text)
  if [ "$TASK_STATUS" != "0" ]; then
    echo "Migration task failed with exit code $TASK_STATUS"
    echo "Rolling back to previous image tag ${CURRENT_TAG}"
    
    # Roll back to previous image tag
    terraform -chdir=$TERRAFORM_ROOT/app apply -var="image_tag=${CURRENT_TAG}" -auto-approve
    
    # Wait for rollback to stabilize
    echo "Waiting for rollback to stabilize..."
    aws ecs wait services-stable --cluster ${APP_NAME}-cluster --services ${APP_NAME}
    
    echo "Rollback complete"
    exit 1
  fi

  echo "Deployment and migrations complete!"
else
  echo "Current deployment already using image tag ${GIT_SHA}, skipping deploy"
fi
