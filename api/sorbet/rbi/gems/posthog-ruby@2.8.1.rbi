# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `posthog-ruby` gem.
# Please instead update this file by running `bin/tapioca gem posthog-ruby`.


# Represents the reason why a flag was enabled/disabled
#
# source://posthog-ruby//lib/posthog/feature_flag.rb#39
class EvaluationReason
  # @return [EvaluationReason] a new instance of EvaluationReason
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#42
  def initialize(json); end

  # Returns the value of attribute code.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#40
  def code; end

  # Returns the value of attribute condition_index.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#40
  def condition_index; end

  # Returns the value of attribute description.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#40
  def description; end
end

# Represents a feature flag returned by /decide v4
#
# source://posthog-ruby//lib/posthog/feature_flag.rb#2
class FeatureFlag
  # @return [FeatureFlag] a new instance of FeatureFlag
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#5
  def initialize(json); end

  # Returns the value of attribute enabled.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#3
  def enabled; end

  # source://posthog-ruby//lib/posthog/feature_flag.rb#14
  def get_value; end

  # Returns the value of attribute key.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#3
  def key; end

  # Returns the value of attribute metadata.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#3
  def metadata; end

  # source://posthog-ruby//lib/posthog/feature_flag.rb#18
  def payload; end

  # Returns the value of attribute reason.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#3
  def reason; end

  # Returns the value of attribute variant.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#3
  def variant; end

  class << self
    # source://posthog-ruby//lib/posthog/feature_flag.rb#22
    def from_value_and_payload(key, value, payload); end
  end
end

# Represents metadata about a feature flag
#
# source://posthog-ruby//lib/posthog/feature_flag.rb#51
class FeatureFlagMetadata
  # @return [FeatureFlagMetadata] a new instance of FeatureFlagMetadata
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#54
  def initialize(json); end

  # Returns the value of attribute description.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#52
  def description; end

  # Returns the value of attribute id.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#52
  def id; end

  # Returns the value of attribute payload.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#52
  def payload; end

  # Returns the value of attribute version.
  #
  # source://posthog-ruby//lib/posthog/feature_flag.rb#52
  def version; end
end

# A worker that doesn't consume jobs
#
# source://posthog-ruby//lib/posthog/version.rb#1
class PostHog; end

# source://posthog-ruby//lib/posthog/backoff_policy.rb#4
class PostHog::BackoffPolicy
  include ::PostHog::Defaults::BackoffPolicy

  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [BackoffPolicy] a new instance of BackoffPolicy
  #
  # source://posthog-ruby//lib/posthog/backoff_policy.rb#14
  def initialize(opts = T.unsafe(nil)); end

  # @return [Numeric] the next backoff interval, in milliseconds.
  #
  # source://posthog-ruby//lib/posthog/backoff_policy.rb#25
  def next_interval; end

  private

  # source://posthog-ruby//lib/posthog/backoff_policy.rb#36
  def add_jitter(base, randomization_factor); end
end

# source://posthog-ruby//lib/posthog/client.rb#12
class PostHog::Client
  include ::PostHog::Utils
  include ::PostHog::Logging

  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Client] a new instance of Client
  #
  # source://posthog-ruby//lib/posthog/client.rb#27
  def initialize(opts = T.unsafe(nil)); end

  # Aliases a user from one id to another
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  #
  # source://posthog-ruby//lib/posthog/client.rb#135
  def alias(attrs); end

  # Captures an event
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  #
  # source://posthog-ruby//lib/posthog/client.rb#92
  def capture(attrs); end

  # Clears the queue without waiting.
  #
  # Use only in test mode
  #
  # source://posthog-ruby//lib/posthog/client.rb#74
  def clear; end

  # @return [Hash] pops the last message from the queue
  #
  # source://posthog-ruby//lib/posthog/client.rb#141
  def dequeue_last_message; end

  # Synchronously waits until the worker has cleared the queue.
  #
  # Use only for scripts which are not long-running, and will specifically
  # exit
  #
  # source://posthog-ruby//lib/posthog/client.rb#64
  def flush; end

  # Returns all flags for a given user
  #
  # @param distinct_id [String] The distinct id of the user
  # @param groups [Hash]
  # @param person_properties [Hash] key-value pairs of properties to associate with the user.
  # @param group_properties [Hash]
  # @return [Hash] String (not symbol) key value pairs of flag and their values
  #
  # source://posthog-ruby//lib/posthog/client.rb#215
  def get_all_flags(distinct_id, groups: T.unsafe(nil), person_properties: T.unsafe(nil), group_properties: T.unsafe(nil), only_evaluate_locally: T.unsafe(nil)); end

  # Returns all flags and payloads for a given user
  #
  # @option [Hash]
  # @option [Hash]
  # @option [Hash]
  # @option [Boolean]
  # @param distinct_id [String] The distinct id of the user
  # @param [Hash] [Hash] a customizable set of options
  # @param [Boolean] [Hash] a customizable set of options
  # @return [Hash] A hash with the following keys:
  #   featureFlags: A hash of feature flags
  #   featureFlagPayloads: A hash of feature flag payloads
  #
  # source://posthog-ruby//lib/posthog/client.rb#247
  def get_all_flags_and_payloads(distinct_id, groups: T.unsafe(nil), person_properties: T.unsafe(nil), group_properties: T.unsafe(nil), only_evaluate_locally: T.unsafe(nil)); end

  # Returns whether the given feature flag is enabled for the given user or not
  #
  # The provided properties are used to calculate feature flags locally, if possible.
  #
  # `groups` are a mapping from group type to group key. So, if you have a group type of "organization" and a group key of "5",
  # you would pass groups={"organization": "5"}.
  # `group_properties` take the format: { group_type_name: { group_properties } }
  # So, for example, if you have the group type "organization" and the group key "5", with the properties name, and employee count,
  # you'll send these as:
  # ```ruby
  #     group_properties: {"organization": {"name": "PostHog", "employees": 11}}
  # ```
  #
  # @param key [String] The key of the feature flag
  # @param distinct_id [String] The distinct id of the user
  # @param groups [Hash]
  # @param person_properties [Hash] key-value pairs of properties to associate with the user.
  # @param group_properties [Hash]
  # @return [String, nil] The value of the feature flag
  #
  # source://posthog-ruby//lib/posthog/client.rb#184
  def get_feature_flag(key, distinct_id, groups: T.unsafe(nil), person_properties: T.unsafe(nil), group_properties: T.unsafe(nil), only_evaluate_locally: T.unsafe(nil), send_feature_flag_events: T.unsafe(nil)); end

  # Returns payload for a given feature flag
  #
  # @option [String
  # @option [Hash]
  # @option [Hash]
  # @option [Hash]
  # @option [Boolean]
  # @param key [String] The key of the feature flag
  # @param distinct_id [String] The distinct id of the user
  # @param [String [Hash] a customizable set of options
  # @param [Hash] [Hash] a customizable set of options
  # @param [Boolean] [Hash] a customizable set of options
  #
  # source://posthog-ruby//lib/posthog/client.rb#230
  def get_feature_flag_payload(key, distinct_id, match_value: T.unsafe(nil), groups: T.unsafe(nil), person_properties: T.unsafe(nil), group_properties: T.unsafe(nil), only_evaluate_locally: T.unsafe(nil)); end

  # @param flag_key [String] The unique flag key of the feature flag
  # @return [String] The decrypted value of the feature flag payload
  #
  # source://posthog-ruby//lib/posthog/client.rb#160
  def get_remote_config_payload(flag_key); end

  # Identifies a group
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  #
  # source://posthog-ruby//lib/posthog/client.rb#124
  def group_identify(attrs); end

  # Identifies a user
  #
  # @option attrs
  # @option attrs
  # @option attrs
  # @option attrs
  # @param attrs [Hash]
  #
  # source://posthog-ruby//lib/posthog/client.rb#110
  def identify(attrs); end

  # source://posthog-ruby//lib/posthog/client.rb#150
  def is_feature_enabled(flag_key, distinct_id, groups: T.unsafe(nil), person_properties: T.unsafe(nil), group_properties: T.unsafe(nil), only_evaluate_locally: T.unsafe(nil), send_feature_flag_events: T.unsafe(nil)); end

  # @return [Fixnum] number of messages in the queue
  #
  # source://posthog-ruby//lib/posthog/client.rb#146
  def queued_messages; end

  # source://posthog-ruby//lib/posthog/client.rb#254
  def reload_feature_flags; end

  # source://posthog-ruby//lib/posthog/client.rb#264
  def shutdown; end

  private

  # source://posthog-ruby//lib/posthog/client.rb#310
  def add_local_person_and_group_properties(distinct_id, groups, person_properties, group_properties); end

  # private: Checks that the api_key is properly initialized
  #
  # @raise [ArgumentError]
  #
  # source://posthog-ruby//lib/posthog/client.rb#294
  def check_api_key!; end

  # private: Enqueues the action.
  #
  # returns Boolean of whether the item was added to the queue.
  #
  # source://posthog-ruby//lib/posthog/client.rb#274
  def enqueue(action); end

  # source://posthog-ruby//lib/posthog/client.rb#298
  def ensure_worker_running; end

  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/client.rb#306
  def worker_running?; end

  class << self
    # source://posthog-ruby//lib/posthog/logging.rb#58
    def logger; end
  end
end

# source://posthog-ruby//lib/posthog/defaults.rb#2
module PostHog::Defaults; end

# source://posthog-ruby//lib/posthog/defaults.rb#36
module PostHog::Defaults::BackoffPolicy; end

# source://posthog-ruby//lib/posthog/defaults.rb#38
PostHog::Defaults::BackoffPolicy::MAX_TIMEOUT_MS = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#37
PostHog::Defaults::BackoffPolicy::MIN_TIMEOUT_MS = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#39
PostHog::Defaults::BackoffPolicy::MULTIPLIER = T.let(T.unsafe(nil), Float)

# source://posthog-ruby//lib/posthog/defaults.rb#40
PostHog::Defaults::BackoffPolicy::RANDOMIZATION_FACTOR = T.let(T.unsafe(nil), Float)

# source://posthog-ruby//lib/posthog/defaults.rb#19
module PostHog::Defaults::FeatureFlags; end

# source://posthog-ruby//lib/posthog/defaults.rb#20
PostHog::Defaults::FeatureFlags::FLAG_REQUEST_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#4
PostHog::Defaults::MAX_HASH_SIZE = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#27
module PostHog::Defaults::Message; end

# 32Kb
#
# source://posthog-ruby//lib/posthog/defaults.rb#28
PostHog::Defaults::Message::MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#31
module PostHog::Defaults::MessageBatch; end

# 500Kb
#
# source://posthog-ruby//lib/posthog/defaults.rb#32
PostHog::Defaults::MessageBatch::MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#33
PostHog::Defaults::MessageBatch::MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#23
module PostHog::Defaults::Queue; end

# source://posthog-ruby//lib/posthog/defaults.rb#24
PostHog::Defaults::Queue::MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#6
module PostHog::Defaults::Request; end

# source://posthog-ruby//lib/posthog/defaults.rb#11
PostHog::Defaults::Request::HEADERS = T.let(T.unsafe(nil), Hash)

# source://posthog-ruby//lib/posthog/defaults.rb#7
PostHog::Defaults::Request::HOST = T.let(T.unsafe(nil), String)

# source://posthog-ruby//lib/posthog/defaults.rb#9
PostHog::Defaults::Request::PATH = T.let(T.unsafe(nil), String)

# source://posthog-ruby//lib/posthog/defaults.rb#8
PostHog::Defaults::Request::PORT = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#16
PostHog::Defaults::Request::RETRIES = T.let(T.unsafe(nil), Integer)

# source://posthog-ruby//lib/posthog/defaults.rb#10
PostHog::Defaults::Request::SSL = T.let(T.unsafe(nil), TrueClass)

# source://posthog-ruby//lib/posthog/feature_flags.rb#14
class PostHog::FeatureFlagsPoller
  include ::PostHog::Logging
  include ::PostHog::Utils

  # @return [FeatureFlagsPoller] a new instance of FeatureFlagsPoller
  #
  # source://posthog-ruby//lib/posthog/feature_flags.rb#18
  def initialize(polling_interval, personal_api_key, project_api_key, host, feature_flag_request_timeout_seconds, on_error = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#168
  def get_all_flags(distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil), only_evaluate_locally = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#178
  def get_all_flags_and_payloads(distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil), only_evaluate_locally = T.unsafe(nil), raise_on_error = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#73
  def get_decide(distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#107
  def get_feature_flag(key, distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil), only_evaluate_locally = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#227
  def get_feature_flag_payload(key, distinct_id, match_value = T.unsafe(nil), groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil), only_evaluate_locally = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#63
  def get_feature_payloads(distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil), only_evaluate_locally = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#52
  def get_feature_variants(distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil), raise_on_error = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#103
  def get_remote_config_payload(flag_key); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#46
  def load_feature_flags(force_reload = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#249
  def shutdown_poller; end

  private

  # source://posthog-ruby//lib/posthog/feature_flags.rb#383
  def _compute_flag_locally(flag, distinct_id, groups = T.unsafe(nil), person_properties = T.unsafe(nil), group_properties = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#419
  def _compute_flag_payload_locally(key, match_value); end

  # This function takes a distinct_id and a feature flag key and returns a float between 0 and 1.
  # Given the same distinct_id and key, it'll always return the same float. These floats are
  # uniformly distributed between 0 and 1, so if we want to show this feature to 20% of traffic
  # we can do _hash(key, distinct_id) < 0.2
  #
  # source://posthog-ruby//lib/posthog/feature_flags.rb#495
  def _hash(key, distinct_id, salt = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#522
  def _load_feature_flags; end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#587
  def _request(uri, request_object, timeout = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#560
  def _request_feature_flag_definitions; end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#568
  def _request_feature_flag_evaluation(data = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#578
  def _request_remote_config_payload(flag_key); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#500
  def get_matching_variant(flag, distinct_id); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#471
  def is_condition_match(flag, distinct_id, condition, properties); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#431
  def match_feature_flag_properties(flag, distinct_id, properties); end

  # source://posthog-ruby//lib/posthog/feature_flags.rb#508
  def variant_lookup_table(flag); end

  class << self
    # Class methods
    #
    # source://posthog-ruby//lib/posthog/feature_flags.rb#255
    def compare(lhs, rhs, operator); end

    # source://posthog-ruby//lib/posthog/logging.rb#58
    def logger; end

    # source://posthog-ruby//lib/posthog/feature_flags.rb#301
    def match_property(property, property_values); end

    # source://posthog-ruby//lib/posthog/feature_flags.rb#269
    def relative_date_parse_for_feature_flag_matching(value); end
  end
end

# source://posthog-ruby//lib/posthog/field_parser.rb#2
class PostHog::FieldParser
  extend ::PostHog::Utils

  class << self
    # In addition to the common fields, alias accepts:
    #
    # - "alias"
    #
    # source://posthog-ruby//lib/posthog/field_parser.rb#87
    def parse_for_alias(fields); end

    # In addition to the common fields, capture accepts:
    #
    # - "event"
    # - "properties"
    # - "groups"
    #
    # source://posthog-ruby//lib/posthog/field_parser.rb#11
    def parse_for_capture(fields); end

    # source://posthog-ruby//lib/posthog/field_parser.rb#58
    def parse_for_group_identify(fields); end

    # In addition to the common fields, identify accepts:
    #
    # - "properties"
    #
    # source://posthog-ruby//lib/posthog/field_parser.rb#40
    def parse_for_identify(fields); end

    private

    # @raise [ArgumentError]
    #
    # source://posthog-ruby//lib/posthog/field_parser.rb#167
    def check_is_hash!(obj, name); end

    # private: Ensures that a string is non-empty
    #
    # obj    - String|Number that must be non-blank
    # name   - Name of the validated value
    #
    # source://posthog-ruby//lib/posthog/field_parser.rb#161
    def check_presence!(obj, name); end

    # source://posthog-ruby//lib/posthog/field_parser.rb#151
    def check_timestamp!(timestamp); end

    # Common fields are:
    #
    # - "timestamp"
    # - "distinct_id"
    # - "message_id"
    # - "send_feature_flags"
    #
    # source://posthog-ruby//lib/posthog/field_parser.rb#116
    def parse_common_fields(fields); end
  end
end

# source://posthog-ruby//lib/posthog/utils.rb#5
class PostHog::InconclusiveMatchError < ::StandardError; end

# source://posthog-ruby//lib/posthog/logging.rb#36
module PostHog::Logging
  # source://posthog-ruby//lib/posthog/logging.rb#64
  def logger; end

  class << self
    # @private
    #
    # source://posthog-ruby//lib/posthog/logging.rb#56
    def included(base); end

    # source://posthog-ruby//lib/posthog/logging.rb#38
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://posthog-ruby//lib/posthog/logging.rb#53
    def logger=(_arg0); end
  end
end

# A batch of `Message`s to be sent to the API
#
# source://posthog-ruby//lib/posthog/message_batch.rb#6
class PostHog::MessageBatch
  include ::PostHog::Logging
  include ::PostHog::Defaults::MessageBatch
  extend ::Forwardable

  # @return [MessageBatch] a new instance of MessageBatch
  #
  # source://posthog-ruby//lib/posthog/message_batch.rb#14
  def initialize(max_message_count); end

  # source://posthog-ruby//lib/posthog/message_batch.rb#20
  def <<(message); end

  # source://posthog-ruby//lib/posthog/message_batch.rb#40
  def clear; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/message_batch.rb#36
  def full?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def length(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_json(*args, **_arg1, &block); end

  private

  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/message_batch.rb#51
  def item_count_exhausted?; end

  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/message_batch.rb#55
  def message_too_big?(message_json_size); end

  # We consider the max size here as just enough to leave room for one more
  # message of the largest size possible. This is a shortcut that allows us
  # to use a native Ruby `Queue` that doesn't allow peeking. The tradeoff
  # here is that we might fit in less messages than possible into a batch.
  #
  # The alternative is to use our own `Queue` implementation that allows
  # peeking, and to consider the next message size when calculating whether
  # the message can be accomodated in this batch.
  #
  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/message_batch.rb#67
  def size_exhausted?; end

  class << self
    # source://posthog-ruby//lib/posthog/logging.rb#58
    def logger; end
  end
end

# source://posthog-ruby//lib/posthog/message_batch.rb#7
class PostHog::MessageBatch::JSONGenerationError < ::StandardError; end

# source://posthog-ruby//lib/posthog/noop_worker.rb#3
class PostHog::NoopWorker
  # @return [NoopWorker] a new instance of NoopWorker
  #
  # source://posthog-ruby//lib/posthog/noop_worker.rb#4
  def initialize(queue); end

  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/noop_worker.rb#12
  def is_requesting?; end

  # source://posthog-ruby//lib/posthog/noop_worker.rb#8
  def run; end
end

# Wraps an existing logger and adds a prefix to all messages
#
# source://posthog-ruby//lib/posthog/logging.rb#5
class PostHog::PrefixedLogger
  # @return [PrefixedLogger] a new instance of PrefixedLogger
  #
  # source://posthog-ruby//lib/posthog/logging.rb#6
  def initialize(logger, prefix); end

  # source://posthog-ruby//lib/posthog/logging.rb#11
  def debug(msg); end

  # source://posthog-ruby//lib/posthog/logging.rb#23
  def error(msg); end

  # source://posthog-ruby//lib/posthog/logging.rb#15
  def info(msg); end

  # source://posthog-ruby//lib/posthog/logging.rb#31
  def level; end

  # source://posthog-ruby//lib/posthog/logging.rb#27
  def level=(severity); end

  # source://posthog-ruby//lib/posthog/logging.rb#19
  def warn(msg); end
end

# source://posthog-ruby//lib/posthog/response.rb#2
class PostHog::Response
  # public: Simple class to wrap responses from the API
  #
  # @return [Response] a new instance of Response
  #
  # source://posthog-ruby//lib/posthog/response.rb#8
  def initialize(status = T.unsafe(nil), error = T.unsafe(nil)); end

  # Returns the value of attribute error.
  #
  # source://posthog-ruby//lib/posthog/response.rb#3
  def error; end

  # Returns the value of attribute status.
  #
  # source://posthog-ruby//lib/posthog/response.rb#3
  def status; end
end

# source://posthog-ruby//lib/posthog/send_worker.rb#7
class PostHog::SendWorker
  include ::PostHog::Utils
  include ::PostHog::Defaults
  include ::PostHog::Logging

  # public: Creates a new worker
  #
  # The worker continuously takes messages off the queue
  # and makes requests to the posthog.com api
  #
  # queue   - Queue synchronized between client and worker
  # api_key  - String of the project's API key
  # options - Hash of worker options
  #           batch_size - Fixnum of how many items to send in a batch
  #           on_error   - Proc of what to do on an error
  #
  # @return [SendWorker] a new instance of SendWorker
  #
  # source://posthog-ruby//lib/posthog/send_worker.rb#23
  def initialize(queue, api_key, options = T.unsafe(nil)); end

  # public: Check whether we have outstanding requests.
  #
  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/send_worker.rb#55
  def is_requesting?; end

  # public: Continuously runs the loop to check for new events
  #
  # source://posthog-ruby//lib/posthog/send_worker.rb#36
  def run; end

  private

  # source://posthog-ruby//lib/posthog/send_worker.rb#61
  def consume_message_from_queue!; end

  class << self
    # source://posthog-ruby//lib/posthog/logging.rb#58
    def logger; end
  end
end

# source://posthog-ruby//lib/posthog/transport.rb#11
class PostHog::Transport
  include ::PostHog::Defaults::Request
  include ::PostHog::Utils
  include ::PostHog::Logging

  # @return [Transport] a new instance of Transport
  #
  # source://posthog-ruby//lib/posthog/transport.rb#16
  def initialize(options = T.unsafe(nil)); end

  # Sends a batch of messages to the API
  #
  # @return [Response] API response
  #
  # source://posthog-ruby//lib/posthog/transport.rb#47
  def send(api_key, batch); end

  # Closes a persistent connection if it exists
  #
  # source://posthog-ruby//lib/posthog/transport.rb#71
  def shutdown; end

  private

  # Takes a block that returns [result, should_retry].
  #
  # Retries upto `retries_remaining` times, if `should_retry` is false or
  # an exception is raised. `@backoff_policy` is used to determine the
  # duration to sleep between attempts
  #
  # Returns [last_result, raised_exception]
  #
  # source://posthog-ruby//lib/posthog/transport.rb#97
  def retry_with_backoff(retries_remaining, &block); end

  # Sends a request for the batch, returns [status_code, body]
  #
  # source://posthog-ruby//lib/posthog/transport.rb#119
  def send_request(api_key, batch); end

  # @return [Boolean]
  #
  # source://posthog-ruby//lib/posthog/transport.rb#77
  def should_retry_request?(status_code, body); end

  class << self
    # source://posthog-ruby//lib/posthog/logging.rb#58
    def logger; end

    # source://posthog-ruby//lib/posthog/transport.rb#139
    def stub; end

    # Sets the attribute stub
    #
    # @param value the value to set the attribute stub to.
    #
    # source://posthog-ruby//lib/posthog/transport.rb#137
    def stub=(_arg0); end
  end
end

# source://posthog-ruby//lib/posthog/utils.rb#8
module PostHog::Utils
  extend ::PostHog::Utils

  # source://posthog-ruby//lib/posthog/utils.rb#90
  def convert_to_datetime(value); end

  # source://posthog-ruby//lib/posthog/utils.rb#73
  def date_in_iso8601(date); end

  # source://posthog-ruby//lib/posthog/utils.rb#53
  def datetime_in_iso8601(datetime); end

  # source://posthog-ruby//lib/posthog/utils.rb#77
  def formatted_offset(time, colon = T.unsafe(nil), alternate_utc_string = T.unsafe(nil)); end

  # source://posthog-ruby//lib/posthog/utils.rb#109
  def is_valid_regex(regex); end

  # public: Returns a new hash with all the date values in the into iso8601
  #         strings
  #
  # source://posthog-ruby//lib/posthog/utils.rb#32
  def isoify_dates(hash); end

  # public: Converts all the date values in the into iso8601 strings in place
  #
  # source://posthog-ruby//lib/posthog/utils.rb#40
  def isoify_dates!(hash); end

  # source://posthog-ruby//lib/posthog/utils.rb#82
  def seconds_to_utc_offset(seconds, colon = T.unsafe(nil)); end

  # public: Return a new hash with keys as strings
  #
  # source://posthog-ruby//lib/posthog/utils.rb#25
  def stringify_keys(hash); end

  # public: Return a new hash with keys converted from strings to symbols
  #
  # source://posthog-ruby//lib/posthog/utils.rb#13
  def symbolize_keys(hash); end

  # public: Convert hash keys from strings to symbols in place
  #
  # source://posthog-ruby//lib/posthog/utils.rb#19
  def symbolize_keys!(hash); end

  # source://posthog-ruby//lib/posthog/utils.rb#66
  def time_in_iso8601(time, fraction_digits = T.unsafe(nil)); end

  # public: Returns a uid string
  #
  # source://posthog-ruby//lib/posthog/utils.rb#46
  def uid; end
end

# source://posthog-ruby//lib/posthog/utils.rb#118
class PostHog::Utils::SizeLimitedHash < ::Hash
  # @return [SizeLimitedHash] a new instance of SizeLimitedHash
  #
  # source://posthog-ruby//lib/posthog/utils.rb#119
  def initialize(max_length, *args, &block); end

  # source://posthog-ruby//lib/posthog/utils.rb#124
  def []=(key, value); end
end

# source://posthog-ruby//lib/posthog/utils.rb#107
PostHog::Utils::UTC_OFFSET_WITHOUT_COLON = T.let(T.unsafe(nil), String)

# source://posthog-ruby//lib/posthog/utils.rb#106
PostHog::Utils::UTC_OFFSET_WITH_COLON = T.let(T.unsafe(nil), String)

# source://posthog-ruby//lib/posthog/version.rb#2
PostHog::VERSION = T.let(T.unsafe(nil), String)
