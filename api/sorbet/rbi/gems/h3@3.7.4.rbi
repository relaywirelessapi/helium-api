# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `h3` gem.
# Please instead update this file by running `bin/tapioca gem h3`.


# The main H3 namespace.
#
# All public methods for the library are defined here.
#
# @see https://uber.github.io/h3/#/documentation/overview/introduction
#
# source://h3//lib/h3.rb#12
module H3
  extend ::H3::GeoJson
  extend ::H3::Bindings::Structs
  extend ::H3::Bindings::Types
  extend ::H3::Hierarchy
  extend ::H3::Miscellaneous
  extend ::H3::Indexing
  extend ::H3::Inspection
  extend ::H3::Regions
  extend ::H3::Traversal
  extend ::H3::UnidirectionalEdges
end

# Internal bindings related modules and classes.
#
# These are intended to be used by the library's public methods
# and not to be used directly by client code.
#
# source://h3//lib/h3/hierarchy.rb#0
module H3::Bindings; end

# Base for FFI Bindings.
#
# When extended, this module sets up FFI to use the H3 C library.
#
# source://h3//lib/h3/bindings/base.rb#6
module H3::Bindings::Base
  # source://h3//lib/h3/bindings/base.rb#18
  def attach_predicate_function(name, *args); end

  private

  # source://h3//lib/h3/bindings/base.rb#27
  def rename_function(from, to); end

  class << self
    # @private
    #
    # source://h3//lib/h3/bindings/base.rb#7
    def extended(base); end
  end
end

# Private H3 functions which should not be called directly.
#
# This module provides bindings that do not have to be invoked directly by clients
# of the library. They are used only internally to provide related public interface.
#
# source://h3//lib/h3/bindings/private.rb#7
module H3::Bindings::Private
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  def compact(*_arg0); end
  def destroy_linked_polygon(*_arg0); end
  def geo_to_h3(*_arg0); end
  def get_pentagon_indexes(*_arg0); end
  def h3_faces(*_arg0); end
  def h3_indexes_from_unidirectional_edge(*_arg0); end
  def h3_line(*_arg0); end
  def h3_set_to_linked_geo(*_arg0); end
  def h3_to_children(*_arg0); end
  def h3_to_geo(*_arg0); end
  def h3_to_geo_boundary(*_arg0); end
  def h3_to_string(*_arg0); end
  def h3_unidirectional_edge_boundary(*_arg0); end
  def h3_unidirectional_edges_from_hexagon(*_arg0); end
  def hex_range(*_arg0); end
  def hex_range_distances(*_arg0); end
  def hex_ranges(*_arg0); end
  def hex_ring(*_arg0); end
  def k_ring(*_arg0); end
  def k_ring_distances(*_arg0); end
  def max_polyfill_size(*_arg0); end
  def max_uncompact_size(*_arg0); end
  def point_distance_km(*_arg0); end
  def point_distance_m(*_arg0); end
  def point_distance_rads(*_arg0); end
  def polyfill(*_arg0); end
  def res_0_indexes(*_arg0); end
  def string_to_h3(*_arg0); end
  def uncompact(*_arg0); end

  class << self
    def compact(*_arg0); end
    def destroy_linked_polygon(*_arg0); end
    def geo_to_h3(*_arg0); end
    def get_pentagon_indexes(*_arg0); end
    def h3_faces(*_arg0); end
    def h3_indexes_from_unidirectional_edge(*_arg0); end
    def h3_line(*_arg0); end
    def h3_set_to_linked_geo(*_arg0); end
    def h3_to_children(*_arg0); end
    def h3_to_geo(*_arg0); end
    def h3_to_geo_boundary(*_arg0); end
    def h3_to_string(*_arg0); end
    def h3_unidirectional_edge_boundary(*_arg0); end
    def h3_unidirectional_edges_from_hexagon(*_arg0); end
    def hex_range(*_arg0); end
    def hex_range_distances(*_arg0); end
    def hex_ranges(*_arg0); end
    def hex_ring(*_arg0); end
    def k_ring(*_arg0); end
    def k_ring_distances(*_arg0); end
    def max_polyfill_size(*_arg0); end
    def max_uncompact_size(*_arg0); end
    def point_distance_km(*_arg0); end
    def point_distance_m(*_arg0); end
    def point_distance_rads(*_arg0); end
    def polyfill(*_arg0); end
    def res_0_indexes(*_arg0); end
    def string_to_h3(*_arg0); end
    def uncompact(*_arg0); end
  end
end

# FFI Structs.
#
# These match the structs defined in H3's header file and are required
# to correctly interact with the library's functions.
#
# source://h3//lib/h3/bindings/structs.rb#7
module H3::Bindings::Structs
  extend ::FFI::Library
end

# source://h3//lib/h3/bindings/structs.rb#53
class H3::Bindings::Structs::CoordIJ < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#15
class H3::Bindings::Structs::GeoBoundary < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#10
class H3::Bindings::Structs::GeoCoord < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#20
class H3::Bindings::Structs::GeoFence < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#31
class H3::Bindings::Structs::GeoMultiPolygon < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#25
class H3::Bindings::Structs::GeoPolygon < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#36
class H3::Bindings::Structs::LinkedGeoCoord < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#41
class H3::Bindings::Structs::LinkedGeoLoop < ::FFI::Struct; end

# source://h3//lib/h3/bindings/structs.rb#47
class H3::Bindings::Structs::LinkedGeoPolygon < ::FFI::Struct; end

# Custom FFI Types
#
# source://h3//lib/h3/bindings/types.rb#4
module H3::Bindings::Types; end

# source://h3//lib/h3/bindings/types.rb#62
module H3::Bindings::Types::H3Indexes
  class << self
    # source://h3//lib/h3/bindings/types.rb#64
    def of_size(size); end

    # source://h3//lib/h3/bindings/types.rb#68
    def with_contents(set); end
  end
end

# source://h3//lib/h3/bindings/types.rb#30
class H3::Bindings::Types::H3IndexesIn
  extend ::FFI::DataConverter

  # @return [H3IndexesIn] a new instance of H3IndexesIn
  #
  # source://h3//lib/h3/bindings/types.rb#40
  def initialize(set); end

  # source://h3//lib/h3/bindings/types.rb#45
  def ptr; end

  # Returns the value of attribute size.
  #
  # source://h3//lib/h3/bindings/types.rb#38
  def size; end

  class << self
    # source://h3//lib/h3/bindings/types.rb#34
    def to_native(h3_set_in, _context); end
  end
end

# source://h3//lib/h3/bindings/types.rb#50
class H3::Bindings::Types::H3IndexesOut < ::H3::Bindings::Types::H3IndexesIn
  # @return [H3IndexesOut] a new instance of H3IndexesOut
  #
  # source://h3//lib/h3/bindings/types.rb#53
  def initialize(size); end

  # source://h3//lib/h3/bindings/types.rb#57
  def read; end
end

# A H3 resolution value.
#
# Integer, but must be between 0 and 15 inclusive.
#
# source://h3//lib/h3/bindings/types.rb#8
class H3::Bindings::Types::Resolution
  extend ::FFI::DataConverter

  class << self
    # source://h3//lib/h3/bindings/types.rb#16
    def to_native(value, _context); end

    private

    # @raise [ArgumentError]
    #
    # source://h3//lib/h3/bindings/types.rb#23
    def failure; end
  end
end

# source://h3//lib/h3/bindings/types.rb#12
H3::Bindings::Types::Resolution::RES_RANGE = T.let(T.unsafe(nil), Range)

# GeoJSON helper methods.
#
# This module allows conversions between GeoJSON polygon data and a nested set of coordinates.
#
# It should be noted that H3 describes coordinates as number pairs in the form
#
#   [latitude, longitude]
#
# whereas the GeoJSON standard uses
#
#   [longitude, latitude]
#
# Both use degrees.
#
# == Coordinates Array
#
# We use a nested array to hold coordinates describing a geographical region.
#
# The first element in the array is an external geofence boundary, composed of an array of
# coordinates as 2-element arrays of the form [latitude, longitude].
#
# Any further elements in the array are further geofence arrays of coordinates which describe
# holes that may be present in the polygon.
#
# Specific examples are shown in the individual method details.
#
# @see http://geojson.io geojson.io - A tool to see GeoJSON data rendered on a world map.
# @see https://tools.ietf.org/html/rfc7946 The GeoJSON RFC standard.
#
# source://h3//lib/h3/geo_json.rb#32
module H3::GeoJson
  # Convert a nested array of coordinates to a GeoJSON document
  #
  # @example Convert a set of nested coordinates of Banbury to a GeoJSON document.
  #   coordinates = [
  #   [
  #   [52.24630137198303, -1.7358398437499998], [52.05249047600099, -1.8923950195312498],
  #   [51.891749018068246, -1.56829833984375], [51.91208502557545, -1.27716064453125],
  #   [52.032218104145294, -1.19476318359375], [52.19413974159753, -1.24420166015625],
  #   [52.24125614966341, -1.5902709960937498], [52.24630137198303, -1.7358398437499998]
  #   ],
  #   [
  #   [52.12590076522272, -1.58203125], [52.12590076522272, -1.476287841796875],
  #   [52.075285904832334, -1.46392822265625], [52.06937709602395, -1.58203125],
  #   [52.12590076522272, -1.58203125]
  #   ],
  #   [
  #   [52.01531743663362, -1.4556884765625], [51.97642166216334, -1.483154296875],
  #   [51.96626938051444, -1.3677978515625], [52.0102459910103, -1.3568115234375],
  #   [52.01531743663362, -1.4556884765625]
  #   ]
  #   ]
  #   H3.coordinates_to_geo_json(coordinates)
  #   "{\"type\":\"Polygon\",\"coordinates\":[
  #   [
  #   [-1.7358398437499998,52.24630137198303], [-1.8923950195312498,52.05249047600099],
  #   [-1.56829833984375,51.891749018068246], [-1.27716064453125,51.91208502557545],
  #   [-1.19476318359375,52.032218104145294], [-1.24420166015625,52.19413974159753],
  #   [-1.5902709960937498,52.24125614966341], [-1.7358398437499998,52.24630137198303]
  #   ],
  #   [
  #   [-1.58203125,52.12590076522272], [-1.476287841796875,52.12590076522272],
  #   [-1.46392822265625,52.075285904832334], [-1.58203125,52.06937709602395],
  #   [-1.58203125,52.12590076522272]
  #   ],
  #   [
  #   [-1.4556884765625,52.01531743663362], [-1.483154296875,51.97642166216334],
  #   [-1.3677978515625,51.96626938051444], [-1.3568115234375,52.0102459910103],
  #   [-1.4556884765625,52.01531743663362]
  #   ]
  #   ]}"
  # @param coordinates [Array<Array<Array>>] Nested array of coordinates.
  # @raise [ArgumentError] Failed to parse the given coordinates.
  # @return [String] GeoJSON document.
  #
  # source://h3//lib/h3/geo_json.rb#134
  def coordinates_to_geo_json(coordinates); end

  # Convert a GeoJSON document to a nested array of coordinates.
  #
  # @example Convert a GeoJSON document of Banbury to a set of nested coordinates.
  #   document = "{\"type\":\"Polygon\",\"coordinates\":[
  #   [
  #   [-1.7358398437499998,52.24630137198303], [-1.8923950195312498,52.05249047600099],
  #   [-1.56829833984375,51.891749018068246], [-1.27716064453125,51.91208502557545],
  #   [-1.19476318359375,52.032218104145294], [-1.24420166015625,52.19413974159753],
  #   [-1.5902709960937498,52.24125614966341], [-1.7358398437499998,52.24630137198303]
  #   ],
  #   [
  #   [-1.58203125,52.12590076522272], [-1.476287841796875,52.12590076522272],
  #   [-1.46392822265625,52.075285904832334], [-1.58203125,52.06937709602395],
  #   [-1.58203125,52.12590076522272]
  #   ],
  #   [
  #   [-1.4556884765625,52.01531743663362], [-1.483154296875,51.97642166216334],
  #   [-1.3677978515625,51.96626938051444], [-1.3568115234375,52.0102459910103],
  #   [-1.4556884765625,52.01531743663362]
  #   ]
  #   ]}"
  #   H3.geo_json_to_coordinates(document)
  #   [
  #   [
  #   [52.24630137198303, -1.7358398437499998], [52.05249047600099, -1.8923950195312498],
  #   [51.891749018068246, -1.56829833984375], [51.91208502557545, -1.27716064453125],
  #   [52.032218104145294, -1.19476318359375], [52.19413974159753, -1.24420166015625],
  #   [52.24125614966341, -1.5902709960937498], [52.24630137198303, -1.7358398437499998]
  #   ],
  #   [
  #   [52.12590076522272, -1.58203125], [52.12590076522272, -1.476287841796875],
  #   [52.075285904832334, -1.46392822265625], [52.06937709602395, -1.58203125],
  #   [52.12590076522272, -1.58203125]
  #   ],
  #   [
  #   [52.01531743663362, -1.4556884765625], [51.97642166216334, -1.483154296875],
  #   [51.96626938051444, -1.3677978515625], [52.0102459910103, -1.3568115234375],
  #   [52.01531743663362, -1.4556884765625]
  #   ]
  #   ]
  # @param input [String] The GeoJSON document. This can be a feature collection, feature,
  #   or polygon. If a feature collection is provided, the first feature is used.
  # @raise [ArgumentError] Failed to parse the GeoJSON document.
  # @return [Array<Array<Array>>] Nested array of coordinates.
  #
  # source://h3//lib/h3/geo_json.rb#80
  def geo_json_to_coordinates(input); end

  private

  # @raise [ArgumentError]
  #
  # source://h3//lib/h3/geo_json.rb#167
  def failed_to_parse!; end

  # source://h3//lib/h3/geo_json.rb#155
  def fetch_coordinates(geom); end

  # @raise [ArgumentError]
  #
  # source://h3//lib/h3/geo_json.rb#171
  def invalid_coordinates!; end

  # geo-json coordinates use [lon, lat], h3 uses [lat, lon]
  #
  # source://h3//lib/h3/geo_json.rb#151
  def swap_lat_lon(coordinates); end
end

# Hierarchical grid functions.
#
# @see https://uber.github.io/h3/#/documentation/api-reference/hierarchy
#
# source://h3//lib/h3/hierarchy.rb#5
module H3::Hierarchy
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Returns the center child (finer) index contained by the given index
  # at the given resolution.
  #
  # @example Find center child hexagon.
  #   H3.center_child(613196570357137407, 10)
  #   622203769609814015
  # @param h3_index [Integer] A valid H3 index.
  # @param child_resoluton [Integer] The desired resolution of the center child hexagon.
  # @return [Integer] H3 index of center child hexagon.
  def center_child(*_arg0); end

  # Derive child hexagons contained within the hexagon at the given H3 index.
  #
  # @example Find the child hexagons for a H3 index.
  #   H3.children(613196570357137407, 9)
  #   [
  #   617700169982672895, 617700169982935039, 617700169983197183, 617700169983459327,
  #   617700169983721471, 617700169983983615, 617700169984245759
  #   ]
  # @param h3_index [Integer] A valid H3 index.
  # @param child_resolution [Integer] The desired resolution of hexagons returned.
  # @return [Array<Integer>] H3 indexes of child hexagons.
  #
  # source://h3//lib/h3/hierarchy.rb#64
  def children(h3_index, child_resolution); end

  # Compact a set of H3 indexes as best as possible.
  #
  # In the case where the set cannot be compacted, the set is returned unchanged.
  #
  # @example Compact the given set.
  #   h3_set = [
  #   617700440073043967, 617700440072781823, 617700440073568255, 617700440093229055,
  #   617700440092704767, 617700440100569087, 617700440074092543, 617700440073830399,
  #   617700440074354687, 617700440073306111, 617700440013012991, 617700440013275135,
  #   617700440092180479, 617700440091656191, 617700440092966911, 617700440100831231,
  #   617700440100044799, 617700440101617663, 617700440081956863
  #   ]
  #   H3.compact(h3_set)
  #   [
  #   617700440093229055, 617700440092704767, 617700440100569087, 617700440013012991,
  #   617700440013275135, 617700440092180479, 617700440091656191, 617700440092966911,
  #   617700440100831231, 617700440100044799, 617700440101617663, 617700440081956863,
  #   613196840447246335
  #   ]
  # @param h3_set [Array<Integer>] An array of valid H3 indexes.
  # @raise [RuntimeError] Couldn't attempt to compact given H3 indexes.
  # @return [Array<Integer>] Compacted set of H3 indexes.
  #
  # source://h3//lib/h3/hierarchy.rb#121
  def compact(h3_set); end

  # Derive maximum number of child hexagons possible at given resolution.
  #
  # @example Derive maximum number of child hexagons.
  #   H3.max_children(613196570357137407, 10)
  #   49
  # @param h3_index [Integer] A valid H3 index.
  # @param child_resoluton [Integer] The desired resolution of the child hexagons.
  # @return [Integer] Maximum number of child hexagons possible at given resolution.
  def max_children(*_arg0); end

  # Find the maximum uncompacted size of the given set of H3 indexes.
  #
  # @example Find the maximum uncompacted size of the given set.
  #   h3_set = [
  #   617700440093229055, 617700440092704767, 617700440100569087, 617700440013012991,
  #   617700440013275135, 617700440092180479, 617700440091656191, 617700440092966911,
  #   617700440100831231, 617700440100044799, 617700440101617663, 617700440081956863,
  #   613196840447246335
  #   ]
  #   H3.max_uncompact_size(h3_set, 10)
  #   133
  # @param compacted_set [Array<Integer>] An array of valid H3 indexes.
  # @param resolution [Integer] The desired resolution to uncompact to.
  # @raise [ArgumentError] Given resolution is invalid for h3_set.
  # @return [Integer] Maximum size of uncompacted set.
  #
  # source://h3//lib/h3/hierarchy.rb#89
  def max_uncompact_size(compacted_set, resolution); end

  # Derive the parent hexagon which contains the hexagon at the given H3 index.
  #
  # @example Find the parent hexagon for a H3 index.
  #   H3.parent(613196570357137407, 6)
  #   604189371209351167
  # @param h3_index [Integer] A valid H3 index.
  # @param parent_resoluton [Integer] The desired resolution of the parent hexagon.
  # @return [Integer] H3 index of parent hexagon.
  def parent(*_arg0); end

  # Uncompact a set of H3 indexes to the given resolution.
  #
  # @example Compact the given set.
  #   h3_set = [
  #   617700440093229055, 617700440092704767, 617700440100569087, 617700440013012991,
  #   617700440013275135, 617700440092180479, 617700440091656191, 617700440092966911,
  #   617700440100831231, 617700440100044799, 617700440101617663, 617700440081956863,
  #   613196840447246335
  #   ]
  #   H3.uncompact(h3_set)
  #   [
  #   617700440093229055, 617700440092704767, 617700440100569087, 617700440013012991,
  #   617700440013275135, 617700440092180479, 617700440091656191, 617700440092966911,
  #   617700440100831231, 617700440100044799, 617700440101617663, 617700440081956863,
  #   617700440072781823, 617700440073043967, 617700440073306111, 617700440073568255,
  #   617700440073830399, 617700440074092543, 617700440074354687
  #   ]
  # @param compacted_set [Array<Integer>] An array of valid H3 indexes.
  # @param resolution [Integer] The desired resolution to uncompact to.
  # @raise [RuntimeError] Couldn't attempt to umcompact H3 indexes.
  # @return [Array<Integer>] Uncompacted set of H3 indexes.
  #
  # source://h3//lib/h3/hierarchy.rb#154
  def uncompact(compacted_set, resolution); end

  class << self
    def center_child(*_arg0); end
    def max_children(*_arg0); end
    def parent(*_arg0); end
  end
end

# Indexing functions.
#
# Coordinates are returned in degrees, in the form
#
#   [latitude, longitude]
#
# @see https://uber.github.io/h3/#/documentation/api-reference/indexing
#
# source://h3//lib/h3/indexing.rb#9
module H3::Indexing
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Derive H3 index for the given set of coordinates.
  #
  # @example Derive the H3 index for the given coordinates.
  #   H3.from_geo_coordinates([52.24630137198303, -1.7358398437499998], 9)
  #   617439284584775679
  # @param coords [Array<Integer>] A coordinate pair.
  # @param resolution [Integer] The desired resolution of the H3 index.
  # @raise [ArgumentError] If coordinates are invalid.
  # @return [Integer] H3 index.
  #
  # source://h3//lib/h3/indexing.rb#23
  def from_geo_coordinates(coords, resolution); end

  # Derive the geographical boundary as coordinates for a given H3 index.
  #
  # This will be a set of 6 coordinate pairs matching the vertexes of the
  # hexagon represented by the given H3 index.
  #
  # If the H3 index is a pentagon, there will be only 5 coordinate pairs returned.
  #
  # @example Derive the geographical boundary for the given H3 index.
  #   H3.to_boundary(617439284584775679)
  #   [
  #   [52.247260929171055, -1.736809158397472], [52.24625850761068, -1.7389279144996015],
  #   [52.244516619273476, -1.7384324668792375], [52.243777169245725, -1.7358184256304658],
  #   [52.24477956752282, -1.7336997597088104], [52.246521439109415, -1.7341950448552204]
  #   ]
  # @param h3_index [Integer] A valid H3 index.
  # @return [Array<Array<Integer>>] An array of six coordinate pairs.
  #
  # source://h3//lib/h3/indexing.rb#73
  def to_boundary(h3_index); end

  # Derive coordinates for a given H3 index.
  #
  # The coordinates map to the centre of the hexagon at the given index.
  #
  # @example Derive the central coordinates for the given H3 index.
  #   H3.to_geo_coordinates(617439284584775679)
  #   [52.245519061399506, -1.7363137757391423]
  # @param h3_index [Integer] A valid H3 index.
  # @return [Array<Integer>] A coordinate pair.
  #
  # source://h3//lib/h3/indexing.rb#49
  def to_geo_coordinates(h3_index); end
end

# Index inspection functions.
#
# @see https://uber.github.io/h3/#/documentation/api-reference/inspection
#
# source://h3//lib/h3/inspection.rb#5
module H3::Inspection
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Derives the base cell number of the given H3 index
  #
  # @example Derive the base cell number of a H3 index
  #   H3.base_cell(617700440100569087)
  #   20
  # @param h3_index [Integer] A valid H3 index
  # @return [Integer] Base cell number
  def base_cell(*_arg0); end

  # Determine whether the given H3 index has a resolution with
  # Class III orientation.
  #
  # @example Check if H3 index has a class III resolution.
  #   H3.class_3_resolution?(599686042433355775)
  #   true
  # @param h3_index [Integer] A valid H3 index.
  # @return [Boolean] True if the H3 index has a class III resolution.
  def class_3_resolution?(*_arg0); end

  # Find all icosahedron faces intersected by a given H3 index.
  #
  # @example Find icosahedron faces for given index
  #   H3.faces(585961082523222015)
  #   [1, 2, 6, 7, 11]
  # @param h3_index [Integer] A H3 index.
  # @return [Array<Integer>] Faces. Faces are represented as integers from 0-19, inclusive.
  #
  # source://h3//lib/h3/inspection.rb#132
  def faces(h3_index); end

  # Derives the H3 index for a given hexadecimal string representation.
  #
  # @example Derive the H3 index from the given hexadecimal form.
  #   H3.from_string("8928308280fffff")
  #   617700169958293503
  # @param h3_string [String] A H3 index in hexadecimal form.
  # @raise [ArgumentError] If h3_string is nil
  # @return [Integer] H3 index
  #
  # source://h3//lib/h3/inspection.rb#50
  def from_string(h3_string); end

  # Returns the maximum number of icosahedron faces the given H3 index may intersect.
  #
  # @example Check maximum faces
  #   H3.max_face_count(585961082523222015)
  #   5
  # @param h3_index [Integer] A H3 index.
  # @return [Integer] Maximum possible number of faces
  def max_face_count(*_arg0); end

  # Determine whether the given H3 index is a pentagon.
  #
  # @example Check if H3 index is a pentagon
  #   H3.pentagon?(585961082523222015)
  #   true
  # @param h3_index [Integer] A valid H3 index.
  # @return [Boolean] True if the H3 index is a pentagon.
  def pentagon?(*_arg0); end

  # Derive the resolution of a given H3 index
  #
  # @example Derive the resolution of a H3 index
  #   H3.resolution(617700440100569087)
  #   9
  # @param h3_index [Integer] A valid H3 index
  # @return [Integer] Resolution of H3 index
  def resolution(*_arg0); end

  # Derives the hexadecimal string representation for a given H3 index.
  #
  # @example Derive the given hexadecimal form for the H3 index
  #   H3.to_string(617700169958293503)
  #   "89283470dcbffff"
  # @param h3_index [Integer] A valid H3 index.
  # @return [String] H3 index in hexadecimal form.
  #
  # source://h3//lib/h3/inspection.rb#104
  def to_string(h3_index); end

  # Determine whether the given H3 index is valid.
  #
  # @example Check if H3 index is valid
  #   H3.valid?(599686042433355775)
  #   true
  # @param h3_index [Integer] A H3 index.
  # @return [Boolean] True if the H3 index is valid.
  def valid?(*_arg0); end

  class << self
    def base_cell(*_arg0); end
    def class_3_resolution(*_arg0); end
    def max_face_count(*_arg0); end
    def pentagon(*_arg0); end
    def resolution(*_arg0); end
    def valid(*_arg0); end
  end
end

# source://h3//lib/h3/inspection.rb#8
H3::Inspection::H3_TO_STR_BUF_SIZE = T.let(T.unsafe(nil), Integer)

# Miscellaneous functions.
#
# @see https://uber.github.io/h3/#/documentation/api-reference/miscellaneous
#
# source://h3//lib/h3/miscellaneous.rb#5
module H3::Miscellaneous
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Returns the number of resolution 0 hexagons (base cells).
  #
  # @example Return the number of base cells
  #   H3.base_cell_count
  #   122
  # @return [Integer] The number of resolution 0 hexagons (base cells).
  def base_cell_count(*_arg0); end

  # Returns all resolution 0 hexagons (base cells).
  #
  # @example Return all base cells.
  #   H3.base_cells
  #   [576495936675512319, 576531121047601151, ..., 580753245698260991]
  # @return [Array<Integer>] All resolution 0 hexagons (base cells).
  #
  # source://h3//lib/h3/miscellaneous.rb#228
  def base_cells; end

  # Area of a given cell expressed in km squared
  #
  # @example Return the area of the cell
  #   H3.cell_area_km2(617700169958293503)
  #   0.10939818864648902
  # @return [Double] Area of cell in km2
  def cell_area_km2(*_arg0); end

  # Area of a given cell expressed in metres squared
  #
  # @example Return the area of the cell
  #   H3.cell_area_m2(617700169958293503)
  #   109398.18864648901
  # @return [Double] Area of cell in metres squared
  def cell_area_m2(*_arg0); end

  # Area of a given cell expressed in radians squared
  #
  # @example Return the area of the cell
  #   H3.cell_area_rads2(617700169958293503)
  #   2.6952182709835757e-09
  # @return [Double] Area of cell in rads2
  def cell_area_rads2(*_arg0); end

  # Convert a number expressed in degrees to its equivalent in radians.
  #
  # @example Convert degrees value to radians.
  #   H3.degs_to_rads(19.61922082086965)
  #   0.34242
  # @param degs [Float] Value expressed in degrees.
  # @return [Float] Value expressed in radians.
  def degs_to_rads(*_arg0); end

  # Derive the length of a hexagon edge in kilometres at the given resolution.
  #
  # @example Derive length of edge in kilometres
  #   H3.edge_length_km(3)
  #   59.81085794
  # @param resolution [Integer] Resolution.
  # @return [Float] Length of edge in kilometres
  def edge_length_km(*_arg0); end

  # Derive the length of a hexagon edge in metres at the given resolution.
  #
  # @example Derive length of edge in metres
  #   H3.edge_length_m(6)
  #   3229.482772
  # @param resolution [Integer] Resolution.
  # @return [Float] Length of edge in metres
  def edge_length_m(*_arg0); end

  # Exact length of edge in kilometres
  #
  # @example Return the edge length
  #   H3.exact_edge_length_km(1266218516299644927)
  #   3.287684056071637e-05
  # @return [Double] Edge length in kilometres
  def exact_edge_length_km(*_arg0); end

  # Exact length of edge in metres
  #
  # @example Return the edge length
  #   H3.exact_edge_length_m(1266218516299644927)
  #   3.287684056071637e-05
  # @return [Double] Edge length in metres
  def exact_edge_length_m(*_arg0); end

  # Exact length of edge in rads
  #
  # @example Return the edge length
  #   H3.exact_edge_length_rads(1266218516299644927)
  #   3.287684056071637e-05
  # @return [Double] Edge length in rads
  def exact_edge_length_rads(*_arg0); end

  # Average hexagon area in square kilometres at the given resolution.
  #
  # @example Find the square kilometre size at resolution 5
  #   H3.hex_area_km2(5)
  #   252.9033645
  # @param resolution [Integer] Resolution.
  # @return [Float] Average hexagon area in square kilometres.
  def hex_area_km2(*_arg0); end

  # Average hexagon area in square metres at the given resolution.
  #
  # @example Find the square metre size at resolution 10
  #   H3.hex_area_m2(10)
  #   15047.5
  # @param resolution [Integer] Resolution.
  # @return [Float] Average hexagon area in square metres.
  def hex_area_m2(*_arg0); end

  # Number of unique H3 indexes at the given resolution.
  #
  # @example Find number of hexagons at resolution 6
  #   H3.hexagon_count(6)
  #   14117882
  # @param resolution [Integer] Resolution.
  # @return [Integer] Number of unique hexagons
  def hexagon_count(*_arg0); end

  # Number of pentagon H3 indexes per resolution.
  # This is always 12, but provided as a convenience.
  #
  # @example Return the number of pentagons
  #   H3.pentagon_count
  #   12
  # @return [Integer] The number of pentagons per resolution.
  def pentagon_count(*_arg0); end

  # Returns all pentagon indexes at the given resolution.
  #
  # @example Return all pentagons at resolution 4.
  #   H3.pentagons(4)
  #   [594615896891195391, 594967740612083711, ..., 598591730937233407]
  # @return [Array<Integer>] All pentagon indexes at the given resolution.
  #
  # source://h3//lib/h3/miscellaneous.rb#241
  def pentagons(resolution); end

  # Returns the kilometres distance between two points.
  #
  # @example Return km distance.
  #   H3.point_distance_km([41.3964809, 2.160444], [41.3870609, 2.164917])
  #   1.1119334622766763
  # @return [Double] KM distance between two points.
  #
  # source://h3//lib/h3/miscellaneous.rb#206
  def point_distance_km(origin, destination); end

  # Returns the metre distance between two points.
  #
  # @example Return metre distance.
  #   H3.point_distance_m([41.3964809, 2.160444], [41.3870609, 2.164917])
  #   1111.9334622766764
  # @return [Double] Metre distance between two points.
  #
  # source://h3//lib/h3/miscellaneous.rb#217
  def point_distance_m(origin, destination); end

  # Returns the radians distance between two points.
  #
  # @example Return radians distance.
  #   H3.point_distance_rads([41.3964809, 2.160444], [41.3870609, 2.164917])
  #   0.00017453024784008713
  # @return [Double] Radians distance between two points.
  #
  # source://h3//lib/h3/miscellaneous.rb#195
  def point_distance_rads(origin, destination); end

  # Convert a number expressed in radians to its equivalent in degrees.
  #
  # @example Convert radians value to degrees.
  #   H3.rads_to_degs(0.34242)
  #   19.61922082086965
  # @param rads [Float] Value expressed in radians.
  # @return [Float] Value expressed in degrees.
  def rads_to_degs(*_arg0); end

  private

  # source://h3//lib/h3/miscellaneous.rb#249
  def build_geocoords(origin, destination); end

  # @raise [ArgumentError]
  #
  # source://h3//lib/h3/miscellaneous.rb#261
  def validate_coordinate(coords); end

  class << self
    def base_cell_count(*_arg0); end
    def cell_area_km2(*_arg0); end
    def cell_area_m2(*_arg0); end
    def cell_area_rads2(*_arg0); end
    def degs_to_rads(*_arg0); end
    def edge_length_km(*_arg0); end
    def edge_length_m(*_arg0); end
    def exact_edge_length_km(*_arg0); end
    def exact_edge_length_m(*_arg0); end
    def exact_edge_length_rads(*_arg0); end
    def hex_area_km2(*_arg0); end
    def hex_area_m2(*_arg0); end
    def hexagon_count(*_arg0); end
    def pentagon_count(*_arg0); end
    def rads_to_degs(*_arg0); end
  end
end

# Region functions.
#
# @see https://uber.github.io/h3/#/documentation/api-reference/regions
#
# source://h3//lib/h3/regions.rb#5
module H3::Regions
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Derive a nested array of coordinates from a list of H3 indexes.
  #
  # @example Get a set of coordinates from a given list of H3 indexes.
  #   h3_indexes = [
  #   599424968551301119, 599424888020664319, 599424970698784767,
  #   599424964256333823, 599424969625042943, 599425001837297663,
  #   599425000763555839
  #   ]
  #   H3.h3_set_to_linked_geo(h3_indexes)
  #   [
  #   [
  #   [52.24425364171531, -1.6470570189756442], [52.19515282473624, -1.7508281227260887],
  #   [52.10973325363767, -1.7265910686763437], [52.06042870859474, -1.8301115887419024],
  #   [51.97490199314513, -1.8057974545517919], [51.9387204737266, -1.6783497689296265],
  #   [51.853128001893175, -1.654344796003053], [51.81682604752331, -1.5274195136674955],
  #   [51.866019925789956, -1.424329996292339], [51.829502535462176, -1.2977583914075301],
  #   [51.87843896218677, -1.1946402363628545], [51.96394676922824, -1.21787542551618],
  #   [52.01267958543637, -1.1145114691876956], [52.09808058649905, -1.1376655003242908],
  #   [52.134791926560325, -1.26456988729442], [52.22012854584846, -1.2880298658365215],
  #   [52.25672060485973, -1.4154623025177386], [52.20787927927604, -1.5192658757247421]
  #   ]
  #   ]
  # @param h3_indexes [Array<Integer>] A list of H3 indexes.
  # @return [Array<Array<Array<Float>>>] Nested array of coordinates.
  #
  # source://h3//lib/h3/regions.rb#139
  def h3_set_to_linked_geo(h3_indexes); end

  # Derive the maximum number of H3 indexes that could be returned from the input.
  #
  # or a coordinates nested array.
  #
  # @example Derive maximum number of hexagons for given GeoJSON document.
  #   geo_json = "{\"type\":\"Polygon\",\"coordinates\":[[[-1.735839843749998,52.24630137198303],
  #   [-1.8923950195312498,52.05249047600099],[-1.56829833984375,51.891749018068246],
  #   [-1.27716064453125,51.91208502557545],[-1.19476318359375,52.032218104145294],
  #   [-1.24420166015625,52.19413974159753],[-1.5902709960937498,52.24125614966341],
  #   [-1.7358398437499998,52.24630137198303]],[[-1.58203125,52.12590076522272],
  #   [-1.476287841796875,52.12590076522272],[-1.46392822265625,52.075285904832334],
  #   [-1.58203125,52.06937709602395],[-1.58203125,52.12590076522272]],
  #   [[-1.4556884765625,52.01531743663362],[-1.483154296875,51.97642166216334],
  #   [-1.3677978515625,51.96626938051444],[-1.3568115234375,52.0102459910103],
  #   [-1.4556884765625,52.01531743663362]]]}"
  #   H3.max_polyfill_size(geo_json, 9)
  #   33391
  # @example Derive maximum number of hexagons for a nested array of coordinates.
  #   coordinates = [
  #   [
  #   [52.24630137198303, -1.7358398437499998], [52.05249047600099, -1.8923950195312498],
  #   [51.891749018068246, -1.56829833984375], [51.91208502557545, -1.27716064453125],
  #   [52.032218104145294, -1.19476318359375], [52.19413974159753, -1.24420166015625],
  #   [52.24125614966341, -1.5902709960937498], [52.24630137198303, -1.7358398437499998]
  #   ],
  #   [
  #   [52.12590076522272, -1.58203125], [52.12590076522272, -1.476287841796875],
  #   [52.075285904832334, -1.46392822265625], [52.06937709602395, -1.58203125],
  #   [52.12590076522272, -1.58203125]
  #   ],
  #   [
  #   [52.01531743663362, -1.4556884765625], [51.97642166216334, -1.483154296875],
  #   [51.96626938051444, -1.3677978515625], [52.0102459910103, -1.3568115234375],
  #   [52.01531743663362, -1.4556884765625]
  #   ]
  #   ]
  #   H3.max_polyfill_size(coordinates, 9)
  #   33391
  # @param geo_polygon [String, Array<Array<Array<Float>>>] Either a GeoJSON string
  # @param resolution [Integer] Resolution.
  # @return [Integer] Maximum number of hexagons needed to polyfill given area.
  #
  # source://h3//lib/h3/regions.rb#51
  def max_polyfill_size(geo_polygon, resolution); end

  # Derive a list of H3 indexes that fall within a given geo polygon structure.
  #
  # coordinates nested array.
  #
  # @example Derive hexagons for given GeoJSON document.
  #   geo_json = "{\"type\":\"Polygon\",\"coordinates\":[[[-1.735839843799998,52.24630137198303],
  #   [-1.8923950195312498,52.05249047600099],[-1.56829833984375,51.891749018068246],
  #   [-1.27716064453125,51.91208502557545],[-1.19476318359375,52.032218104145294],
  #   [-1.24420166015625,52.19413974159753],[-1.5902709960937498,52.24125614966341],
  #   [-1.7358398437499998,52.24630137198303]],[[-1.58203125,52.12590076522272],
  #   [-1.476287841796875,52.12590076522272],[-1.46392822265625,52.075285904832334],
  #   [-1.58203125,52.06937709602395],[-1.58203125,52.12590076522272]],
  #   [[-1.4556884765625,52.01531743663362],[-1.483154296875,51.97642166216334],
  #   [-1.3677978515625,51.96626938051444],[-1.3568115234375,52.0102459910103],
  #   [-1.4556884765625,52.01531743663362]]]}"
  #   H3.polyfill(geo_json, 5)
  #   [
  #   599424968551301119, 599424888020664319, 599424970698784767, 599424964256333823,
  #   599424969625042943, 599425001837297663, 599425000763555839
  #   ]
  # @example Derive hexagons for a nested array of coordinates.
  #   coordinates = [
  #   [
  #   [52.24630137198303, -1.7358398437499998], [52.05249047600099, -1.8923950195312498],
  #   [51.891749018068246, -1.56829833984375], [51.91208502557545, -1.27716064453125],
  #   [52.032218104145294, -1.19476318359375], [52.19413974159753, -1.24420166015625],
  #   [52.24125614966341, -1.5902709960937498], [52.24630137198303, -1.7358398437499998]
  #   ],
  #   [
  #   [52.12590076522272, -1.58203125], [52.12590076522272, -1.476287841796875],
  #   [52.075285904832334, -1.46392822265625], [52.06937709602395, -1.58203125],
  #   [52.12590076522272, -1.58203125]
  #   ],
  #   [
  #   [52.01531743663362, -1.4556884765625], [51.97642166216334, -1.483154296875],
  #   [51.96626938051444, -1.3677978515625], [52.0102459910103, -1.3568115234375],
  #   [52.01531743663362, -1.4556884765625]
  #   ]
  #   ]
  #   H3.polyfill(coordinates, 5)
  #   [
  #   599424968551301119, 599424888020664319, 599424970698784767, 599424964256333823,
  #   599424969625042943, 599425001837297663, 599425000763555839
  #   ]
  # @param geo_polygon [String, Array<Array<Array<Float>>>] Either a GeoJSON string or a
  # @param resolution [Integer] Resolution.
  # @return [Array<Integer>] Hexagons needed to polyfill given area.
  #
  # source://h3//lib/h3/regions.rb#105
  def polyfill(geo_polygon, resolution); end

  private

  # source://h3//lib/h3/regions.rb#227
  def build_geofence(input); end

  # source://h3//lib/h3/regions.rb#208
  def build_polygon(input); end

  # source://h3//lib/h3/regions.rb#201
  def extract_geo_coord(geo_coord); end

  # source://h3//lib/h3/regions.rb#184
  def extract_geo_loop(geo_loop); end

  # source://h3//lib/h3/regions.rb#167
  def extract_geo_polygon(geo_polygon); end

  # source://h3//lib/h3/regions.rb#188
  def extract_linked_geo_coord(linked_geo_coord); end

  # source://h3//lib/h3/regions.rb#171
  def extract_linked_geo_loop(linked_geo_loop); end

  # source://h3//lib/h3/regions.rb#152
  def extract_linked_geo_polygon(linked_geo_polygon); end
end

# Grid traversal functions
#
# @see https://uber.github.io/h3/#/documentation/api-reference/traversal
#
# source://h3//lib/h3/traversal.rb#5
module H3::Traversal
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Derive the distance between two H3 indexes.
  #
  # @example Derive the distance between two H3 indexes.
  #   H3.distance(617700169983721471, 617700169959866367)
  #   5
  # @param origin [Integer] Origin H3 index
  # @param h3_index [Integer] H3 index
  # @return [Integer] Distance between indexes.
  def distance(*_arg0); end

  # Derives H3 indexes within k distance of the origin H3 index.
  #
  # Similar to {k_ring}, except that an error is raised when one of the indexes
  # returned is a pentagon or is in the pentagon distortion area.
  #
  # k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0
  # and all neighboring indexes, and so on.
  #
  # Output is inserted into the array in order of increasing distance from the origin.
  #
  # @example Derive the hex range for a given H3 index with k of 0.
  #   H3.hex_range(617700169983721471, 0)
  #   [617700169983721471]
  # @example Derive the hex range for a given H3 index with k of 1.
  #   H3.hex_range(617700169983721471, 1)
  #   [
  #   617700169983721471, 617700170047946751, 617700169984245759,
  #   617700169982672895, 617700169983983615, 617700170044276735,
  #   617700170044014591
  #   ]
  # @param origin [Integer] Origin H3 index
  # @param k [Integer] K distance.
  # @raise [ArgumentError] Raised if the range contains a pentagon.
  # @return [Array<Integer>] Array of H3 indexes within the k-range.
  #
  # source://h3//lib/h3/traversal.rb#82
  def hex_range(origin, k); end

  # Derives the hex range for the given origin at k distance, sub-grouped by distance.
  #
  # @example Derive hex range at distance 2
  #   H3.hex_range_distances(617700169983721471, 2)
  #   {
  #   0 => [617700169983721471],
  #   1 = >[
  #   617700170047946751, 617700169984245759, 617700169982672895,
  #   617700169983983615, 617700170044276735, 617700170044014591
  #   ],
  #   2 => [
  #   617700170048995327, 617700170047684607, 617700170048471039,
  #   617700169988177919, 617700169983197183, 617700169983459327,
  #   617700169982935039, 617700175096053759, 617700175097102335,
  #   617700170043752447, 617700170043490303, 617700170045063167
  #   ]
  #   }
  # @param origin [Integer] Origin H3 index.
  # @param k [Integer] K distance.
  # @raise [ArgumentError] Raised when the hex range contains a pentagon.
  # @return [Hash] Hex range grouped by distance.
  #
  # source://h3//lib/h3/traversal.rb#233
  def hex_range_distances(origin, k); end

  # Derives H3 indexes within k distance for each H3 index in the set.
  #
  # @example Derive the hex ranges for a given H3 set with k of 0.
  #   H3.hex_ranges([617700169983721471, 617700169982672895], 1)
  #   {
  #   617700169983721471 => [
  #   [617700169983721471],
  #   [
  #   617700170047946751, 617700169984245759, 617700169982672895,
  #   617700169983983615, 617700170044276735, 617700170044014591
  #   ]
  #   ],
  #   617700169982672895 = > [
  #   [617700169982672895],
  #   [
  #   617700169984245759, 617700169983197183, 617700169983459327,
  #   617700169982935039, 617700169983983615, 617700169983721471
  #   ]
  #   ]
  #   }
  # @example Derive the hex ranges for a given H3 set with k of 0 ungrouped.
  #   H3.hex_ranges([617700169983721471, 617700169982672895], 1, grouped: false)
  #   [
  #   617700169983721471, 617700170047946751, 617700169984245759,
  #   617700169982672895, 617700169983983615, 617700170044276735,
  #   617700170044014591, 617700169982672895, 617700169984245759,
  #   617700169983197183, 617700169983459327, 617700169982935039,
  #   617700169983983615, 617700169983721471
  #   ]
  # @param h3_set [Array<Integer>] Set of H3 indexes
  # @param k [Integer] K distance.
  # @param grouped [Boolean] Whether to group the output. Default true.
  # @raise [ArgumentError] Raised if any of the ranges contains a pentagon.
  # @return [Hash] Hash of H3 index keys, with array values grouped by k-ring.
  # @see #hex_range
  #
  # source://h3//lib/h3/traversal.rb#199
  def hex_ranges(h3_set, k, grouped: T.unsafe(nil)); end

  # Derives the hollow hexagonal ring centered at origin with sides of length k.
  #
  # An error is raised when one of the indexes returned is a pentagon or is
  # in the pentagon distortion area.
  #
  # @example Derive the hex ring for the H3 index at k = 1
  #   H3.hex_ring(617700169983721471, 1)
  #   [
  #   617700170044014591, 617700170047946751, 617700169984245759,
  #   617700169982672895, 617700169983983615, 617700170044276735
  #   ]
  # @param origin [Integer] Origin H3 index.
  # @param k [Integer] K distance.
  # @raise [ArgumentError] Raised if the hex ring contains a pentagon.
  # @return [Array<Integer>] Array of H3 indexes within the hex ring.
  #
  # source://h3//lib/h3/traversal.rb#136
  def hex_ring(origin, k); end

  # Derives H3 indexes within k distance of the origin H3 index.
  #
  # k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0
  # and all neighboring indexes, and so on.
  #
  # @example Derive the k-ring for a given H3 index with k of 0.
  #   H3.k_ring(617700169983721471, 0)
  #   [617700169983721471]
  # @example Derive the k-ring for a given H3 index with k of 1.
  #   H3.k_ring(617700169983721471, 1)
  #   [
  #   617700169983721471, 617700170047946751, 617700169984245759,
  #   617700169982672895, 617700169983983615, 617700170044276735,
  #   617700170044014591
  #   ]
  # @param origin [Integer] Origin H3 index
  # @param k [Integer] K distance.
  # @return [Array<Integer>] Array of H3 indexes within the k-range.
  #
  # source://h3//lib/h3/traversal.rb#111
  def k_ring(origin, k); end

  # Derives the k-ring for the given origin at k distance, sub-grouped by distance.
  #
  # @example Derive k-ring at distance 2
  #   H3.k_ring_distances(617700169983721471, 2)
  #   {
  #   0 => [617700169983721471],
  #   1 = >[
  #   617700170047946751, 617700169984245759, 617700169982672895,
  #   617700169983983615, 617700170044276735, 617700170044014591
  #   ],
  #   2 => [
  #   617700170048995327, 617700170047684607, 617700170048471039,
  #   617700169988177919, 617700169983197183, 617700169983459327,
  #   617700169982935039, 617700175096053759, 617700175097102335,
  #   617700170043752447, 617700170043490303, 617700170045063167
  #   ]
  #   }
  # @param origin [Integer] Origin H3 index.
  # @param k [Integer] K distance.
  # @return [Hash] Hash of k-ring distances grouped by distance.
  #
  # source://h3//lib/h3/traversal.rb#270
  def k_ring_distances(origin, k); end

  # Derives the H3 indexes found in a line between an origin H3 index
  # and a destination H3 index (inclusive of origin and destination).
  #
  # @example Derive the indexes found in a line.
  #   H3.line(617700169983721471, 617700169959866367)
  #   [
  #   617700169983721471, 617700169984245759, 617700169988177919,
  #   617700169986867199, 617700169987391487, 617700169959866367
  #   ]
  # @param origin [Integer] Origin H3 index.
  # @param destination [Integer] Destination H3 index.
  # @raise [ArgumentError] Could not compute line
  # @return [Array<Integer>] H3 indexes
  #
  # source://h3//lib/h3/traversal.rb#300
  def line(origin, destination); end

  # Derive the number of hexagons present in a line between two H3 indexes.
  #
  # This value is simply `h3_distance(origin, destination) + 1` when a line is computable.
  #
  # Returns a negative number if a line cannot be computed e.g.
  # a pentagon was encountered, or the hexagons are too far apart.
  #
  # @example Derive the number of hexagons present in a line between two H3 indexes.
  #   H3.line_size(617700169983721471, 617700169959866367)
  #   6
  # @param origin [Integer] Origin H3 index
  # @param destination [Integer] H3 index
  # @return [Integer] Number of hexagons found between indexes.
  def line_size(*_arg0); end

  # Derive the maximum hex ring size for a given distance k.
  #
  # NOTE: This method is not part of the H3 API and is added to this binding for convenience.
  #
  # @example Derive maximum hex ring size for k distance 6.
  #   H3.max_hex_ring_size(6)
  #   36
  # @param k [Integer] K distance.
  # @return [Integer] Maximum hex ring size.
  #
  # source://h3//lib/h3/traversal.rb#155
  def max_hex_ring_size(k); end

  # Derive the maximum k-ring size for distance k.
  #
  # @example Derive the maximum k-ring size for k=5
  #   H3.max_kring_size(5)
  #   91
  # @param k [Integer] K value.
  # @return [Integer] Maximum k-ring size.
  def max_kring_size(*_arg0); end

  private

  # source://h3//lib/h3/traversal.rb#318
  def hex_ranges_ungrouped(h3_set, k); end

  # source://h3//lib/h3/traversal.rb#310
  def k_rings_for_hex_range(indexes, k); end

  class << self
    def distance(*_arg0); end
    def line_size(*_arg0); end
    def max_kring_size(*_arg0); end
  end
end

# Unidirectional edge functions
#
# @see https://uber.github.io/h3/#/documentation/api-reference/unidirectional-edges
#
# source://h3//lib/h3/unidirectional_edges.rb#5
module H3::UnidirectionalEdges
  include ::H3::Bindings::Structs
  include ::H3::Bindings::Types
  extend ::H3::Bindings::Base
  extend ::FFI::Library
  extend ::Gem::Deprecate

  # Derive destination H3 index from edge.
  #
  # @example Get destination index from edge
  #   H3.destination_from_unidirectional_edge(1266218516299644927)
  #   617700169961177087
  # @param edge [Integer] H3 edge index
  # @return [Integer] H3 index
  def destination_from_unidirectional_edge(*_arg0); end

  # Determine whether two H3 indexes are neighbors.
  #
  # @example Check two H3 indexes
  #   H3.neighbors?(617700169958293503, 617700169958031359)
  #   true
  # @param origin [Integer] Origin H3 index
  # @param destination [Integer] Destination H3 index
  # @return [Boolean] True if indexes are neighbors
  def neighbors?(*_arg0); end

  # Derive origin and destination H3 indexes from edge.
  #
  # Returned in the form
  #
  #   [origin, destination]
  #
  # @example Get origin and destination indexes from edge
  #   H3.origin_and_destination_from_unidirectional_edge(1266218516299644927)
  #   [617700169958293503, 617700169961177087]
  # @param edge [Integer] H3 edge index
  # @return [Array<Integer>] H3 index array.
  #
  # source://h3//lib/h3/unidirectional_edges.rb#100
  def origin_and_destination_from_unidirectional_edge(edge); end

  # Derive origin H3 index from edge.
  #
  # @example Get origin index from edge
  #   H3.origin_from_unidirectional_edge(1266218516299644927)
  #   617700169958293503
  # @param edge [Integer] H3 edge index
  # @return [Integer] H3 index
  def origin_from_unidirectional_edge(*_arg0); end

  # Derives the H3 index of the edge from the given H3 indexes.
  #
  # @example Derive the H3 edge index between two H3 indexes
  #   H3.unidirectional_edge(617700169958293503, 617700169958031359)
  #   1626506486489284607
  # @param origin [Integer] H3 index
  # @param destination [Integer] H3 index
  # @return [Integer] H3 edge index
  def unidirectional_edge(*_arg0); end

  # Derive coordinates for edge boundary.
  #
  # @example
  #   H3.unidirectional_edge_boundary(612933930963697663)
  #   [
  #   [68.92995788193981, 31.831280499087402], [69.39359648991828, 62.345344956509784],
  #   [76.163042830191, 94.14309010184775], [87.36469532319619, 145.5581976913368],
  #   [81.27137179020497, -34.75841798028461], [73.31022368544393, 0.32561035194326043]
  #   ]
  # @param edge [Integer] H3 edge index
  # @return [Array<Array<Float>>] Edge boundary coordinates for a hexagon
  #
  # source://h3//lib/h3/unidirectional_edges.rb#139
  def unidirectional_edge_boundary(edge); end

  # Determine whether the given H3 index represents an edge.
  #
  # @example Check if H3 index is a valid unidirectional edge.
  #   H3.unidirectional_edge_valid?(1266218516299644927)
  #   true
  # @param h3_index [Integer] H3 index
  # @return [Boolean] True if H3 index is a valid unidirectional edge
  def unidirectional_edge_valid?(*_arg0); end

  # Derive unidirectional edges for a H3 index.
  #
  # @example Get unidirectional indexes from hexagon
  #   H3.unidirectional_edges_from_hexagon(612933930963697663)
  #   [
  #   1261452277305049087, 1333509871342977023, 1405567465380904959,
  #   1477625059418832895, 1549682653456760831, 1621740247494688767
  #   ]
  # @param origin [Integer] H3 index
  # @return [Array<Integer>] H3 index array.
  #
  # source://h3//lib/h3/unidirectional_edges.rb#119
  def unidirectional_edges_from_hexagon(origin); end

  class << self
    def destination_from_unidirectional_edge(*_arg0); end
    def neighbors(*_arg0); end
    def origin_from_unidirectional_edge(*_arg0); end
    def unidirectional_edge(*_arg0); end
    def unidirectional_edge_valid(*_arg0); end
  end
end

# source://h3//lib/h3/version.rb#2
H3::VERSION = T.let(T.unsafe(nil), String)
