# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-pro` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq-pro`.


# Implements Lua-based schedule enqueuer
#
# source://sidekiq-pro//lib/sidekiq/pro/version.rb#1
module Sidekiq
  class << self
    # source://sidekiq/8.0.7/lib/sidekiq.rb#136
    def configure_client; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#124
    def configure_embed(&block); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#97
    def configure_server(&block); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#89
    def default_configuration; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#85
    def default_job_options; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#81
    def default_job_options=(hash); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#57
    def dump_json(object); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#65
    def ent?; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#102
    def freeze!; end

    # source://sidekiq/8.0.7/lib/sidekiq/version.rb#7
    def gem_version; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#53
    def load_json(string); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#93
    def logger; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#61
    def pro?; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#73
    def redis(&block); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#69
    def redis_pool; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#49
    def server?; end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#77
    def strict_args!(mode = T.unsafe(nil)); end

    # source://sidekiq/8.0.7/lib/sidekiq/transaction_aware_client.rb#46
    def transactional_push!; end

    # Allow targeting of Sidekiq API calls within a block
    # to a specific shard. Usage:
    #
    #   Sidekiq.via(SOME_POOL) do
    #     Sidekiq::Queue.all.sum(&:size)
    #   end
    #
    # source://sidekiq-pro//lib/sidekiq/pro/sharding.rb#8
    def via(pool); end

    # source://sidekiq/8.0.7/lib/sidekiq.rb#45
    def ❨╯°□°❩╯︵┻━┻; end
  end
end

# Provide a higher-level Batch abstraction for units of work.
# Given a set of work, we want to break the set down to individual jobs
# for Sidekiq to process in parallel but then have an overall
# notification when the entire set is complete.
#
#   batch = Sidekiq::Batch.new
#   batch.on(:complete, self.class, :to => current_user.email)
#   batch.jobs do
#     # push messages to sidekiq
#   end
#
# Sidekiq generates a unique Batch ID, along with the number of jobs pushed
# in the batch.
#
# Batches may be nested by creating a new Batch within another batch's +jobs+
# method.  When the child batch runs an event callback, it checks to see if
# it needs to fire the parent batch's event callback too.
#
# source://sidekiq-pro//lib/sidekiq/batch/callback.rb#4
class Sidekiq::Batch
  # @return [Batch] a new instance of Batch
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#80
  def initialize(bid = T.unsafe(nil)); end

  # Returns the value of attribute bid.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#74
  def bid; end

  # Returns the value of attribute callback_queue.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#78
  def callback_queue; end

  # Sets the attribute callback_queue
  #
  # @param value the value to set the attribute callback_queue to.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#78
  def callback_queue=(_arg0); end

  # Returns the value of attribute callbacks.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#75
  def callbacks; end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#117
  def created_at; end

  # Returns the value of attribute description.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#77
  def description; end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#77
  def description=(_arg0); end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#126
  def expires_at; end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#113
  def expiry; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#137
  def include?(jid); end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#144
  def invalidate_all; end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#154
  def invalidate_jids(*jids); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#164
  def invalidated?; end

  # Retrieve the current set of JIDs associated with this batch.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#131
  def jids; end

  # Pass in a block which pushes all the work associated
  # with this batch to Sidekiq.
  #
  # Returns the set of JIDs added to the batch.
  #
  # Note: all jobs defined within the block are pushed to Redis atomically
  # so either the entire set of jobs are defined successfully or none at all.
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#212
  def jobs(&block); end

  # set this per batch to override LINGER, e.g.
  #   batch = Sidekiq::Batch.new
  #   batch.linger = 600 # 10 minutes
  #   batch.jobs { ... }
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#70
  def linger; end

  # set this per batch to override LINGER, e.g.
  #   batch = Sidekiq::Batch.new
  #   batch.linger = 600 # 10 minutes
  #   batch.jobs { ... }
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#70
  def linger=(_arg0); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#175
  def mutable?; end

  # Call a method upon completion or success of a batch.  You
  # may pass a bare Class, which will call "on_#{event}", or a
  # String with the exact 'Class#method' to call.
  #
  #   batch.on(:complete, MyClass)
  #   batch.on(:success, 'MyClass#foo')
  #   batch.on(:complete, MyClass, :email => current_user.email)
  #   batch.on(:death, MyClass, :email => current_user.email)
  #
  # The Class should implement a method signature like this:
  #
  #   def on_complete(status, options)
  #   end
  #
  # @raise [Immutable]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#194
  def on(event, call, options = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#109
  def parent; end

  # Returns the value of attribute parent_bid.
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#76
  def parent_bid; end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#48
  def redis(bid, &block); end

  # Not a public API
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#299
  def register(jid); end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#171
  def status; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#137
  def valid?(jid); end

  private

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch.rb#312
  def immediate_registration?; end

  # source://sidekiq-pro//lib/sidekiq/batch.rb#316
  def increment_batch_jobs_to_redis(conn, jids); end

  class << self
    # source://sidekiq-pro//lib/sidekiq/batch.rb#41
    def newbid; end

    # source://sidekiq-pro//lib/sidekiq/batch.rb#37
    def redis(bid, &block); end
  end
end

# source://sidekiq-pro//lib/sidekiq/batch/callback.rb#5
class Sidekiq::Batch::Callback
  include ::Sidekiq::Job
  include ::Sidekiq::Job::Options
  extend ::Sidekiq::Job::Options::ClassMethods
  extend ::Sidekiq::Job::ClassMethods

  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#12
  def perform(event, bid, queue = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#141
  def sidekiq_options_hash; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#153
  def sidekiq_options_hash=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#141
  def sidekiq_retries_exhausted_block; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#153
  def sidekiq_retries_exhausted_block=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#141
  def sidekiq_retry_in_block; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#153
  def sidekiq_retry_in_block=(_arg0); end

  private

  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#106
  def complete(status, queue); end

  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#32
  def death(status, queue); end

  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#181
  def enqueue_callback(queue, args); end

  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#20
  def execute_callback(status, event, target, options); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#170
  def needs_callback?(bid, cb); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#166
  def needs_complete?(bid); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#162
  def needs_success?(bid); end

  # source://sidekiq-pro//lib/sidekiq/batch/callback.rb#53
  def success(status, queue); end

  class << self
    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#108
    def sidekiq_options_hash; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#116
    def sidekiq_options_hash=(val); end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#108
    def sidekiq_retries_exhausted_block; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#116
    def sidekiq_retries_exhausted_block=(val); end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#108
    def sidekiq_retry_in_block; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#116
    def sidekiq_retry_in_block=(val); end

    private

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#103
    def __synchronized_sidekiq_options_hash; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#103
    def __synchronized_sidekiq_retries_exhausted_block; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#103
    def __synchronized_sidekiq_retry_in_block; end
  end
end

# source://sidekiq-pro//lib/sidekiq/batch/callback.rb#9
Sidekiq::Batch::Callback::COMPLETE = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq/batch/callback.rb#10
Sidekiq::Batch::Callback::DEATH = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq/batch/callback.rb#8
Sidekiq::Batch::Callback::SUCCESS = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#7
class Sidekiq::Batch::Client
  include ::Sidekiq::ServerMiddleware

  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#10
  def call(job_class, msg, queue, redis_pool); end
end

# source://sidekiq-pro//lib/sidekiq/batch/death.rb#33
class Sidekiq::Batch::DeadSet
  include ::Enumerable

  # source://sidekiq-pro//lib/sidekiq/batch/death.rb#42
  def each; end

  # source://sidekiq-pro//lib/sidekiq/batch/death.rb#36
  def size; end
end

# source://sidekiq-pro//lib/sidekiq/batch.rb#57
Sidekiq::Batch::EXPIRY = T.let(T.unsafe(nil), Integer)

# source://sidekiq-pro//lib/sidekiq/batch.rb#31
class Sidekiq::Batch::Empty
  include ::Sidekiq::Job
  include ::Sidekiq::Job::Options
  extend ::Sidekiq::Job::Options::ClassMethods
  extend ::Sidekiq::Job::ClassMethods

  # source://sidekiq-pro//lib/sidekiq/batch.rb#33
  def perform; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#141
  def sidekiq_options_hash; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#153
  def sidekiq_options_hash=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#141
  def sidekiq_retries_exhausted_block; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#153
  def sidekiq_retries_exhausted_block=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#141
  def sidekiq_retry_in_block; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#153
  def sidekiq_retry_in_block=(_arg0); end

  class << self
    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#108
    def sidekiq_options_hash; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#116
    def sidekiq_options_hash=(val); end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#108
    def sidekiq_retries_exhausted_block; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#116
    def sidekiq_retries_exhausted_block=(val); end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#108
    def sidekiq_retry_in_block; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#116
    def sidekiq_retry_in_block=(val); end

    private

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#103
    def __synchronized_sidekiq_options_hash; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#103
    def __synchronized_sidekiq_retries_exhausted_block; end

    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#103
    def __synchronized_sidekiq_retry_in_block; end
  end
end

# source://sidekiq-pro//lib/sidekiq/batch.rb#54
class Sidekiq::Batch::Immutable < ::RuntimeError; end

# Controls how long a batch record "lingers" in Redis before expiring.
# This allows APIs like Status#poll to check batch status even after
# the batch succeeds and is no longer needed.  You can lower this
# constant if you create lots of batches, want to reclaim the memory
# and don't use polling.
#
# source://sidekiq-pro//lib/sidekiq/batch.rb#64
Sidekiq::Batch::LINGER = T.let(T.unsafe(nil), Integer)

# source://sidekiq-pro//lib/sidekiq/batch.rb#52
class Sidekiq::Batch::NoSuchBatch < ::StandardError; end

# source://sidekiq-pro//lib/sidekiq/batch.rb#56
Sidekiq::Batch::ONE_DAY = T.let(T.unsafe(nil), Integer)

# source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#23
class Sidekiq::Batch::Server
  include ::Sidekiq::ServerMiddleware

  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#26
  def call(inst, job, queue); end

  private

  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#122
  def add_failure(bid, job, queue, ex); end

  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#64
  def add_success(bid, jid, queue); end

  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#159
  def enqueue_callback(queue, args); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#111
  def needs_callback?(bid, cb); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#107
  def needs_complete?(bid); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/middleware.rb#103
  def needs_success?(bid); end
end

# A snapshot in time of the current Batch status.
#
# * total - number of jobs in this batch.
# * pending - number of jobs which have not reported success yet.
# * failures - number of jobs which have failed.
#
# Batch job(s) can fail and be retried through Sidekiq's retry feature.
# For this reason, a batch is considered complete once all jobs have
# been executed, even if one or more executions was a failure.
#
# source://sidekiq-pro//lib/sidekiq/batch/status.rb#15
class Sidekiq::Batch::Status
  # @return [Status] a new instance of Status
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#21
  def initialize(bid); end

  # Returns the value of attribute bid.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#16
  def bid; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#74
  def callbacks; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#58
  def child_count; end

  # A Batch is considered complete when no jobs are pending or
  # the only pending jobs have already failed.  Any child batches
  # must have also completed.
  #
  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#179
  def complete?; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#80
  def complete_at; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#88
  def created_at; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#201
  def data; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/death.rb#14
  def dead?; end

  # Callers can scan the DeadSet for the given JIDs to
  # find the canonical copy of the job.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/death.rb#22
  def dead_jids; end

  # source://sidekiq-pro//lib/sidekiq/batch/death.rb#28
  def death_at; end

  # Remove all info about this batch from Redis.  The main batch
  # data hash is kept around for 24 hours so it can be queried for status
  # after success.
  #
  # Returns the bid if anything was deleted, nil if nothing was deleted.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#117
  def delete; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#135
  def deleted?; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#70
  def description; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#107
  def expires_at; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#66
  def expiry; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#145
  def failed_jids; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#171
  def failure_pct; end

  # Returns the value of attribute failures.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#17
  def failures; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#149
  def include?(jid); end

  # returns true if any or all jids in the batch have been invalidated.
  #
  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#156
  def invalidated?; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#139
  def jids; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#183
  def join; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#62
  def linger; end

  # @raise [NoSuchBatch]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#26
  def load_data(bid); end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#52
  def parent; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#46
  def parent_batch; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#42
  def parent_bid; end

  # Returns the value of attribute pending.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#18
  def pending; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#166
  def pending_pct; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#187
  def poll(polling_sleep = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#84
  def success_at; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#161
  def success_pct; end

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#216
  def to_json; end

  # Returns the value of attribute total.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#19
  def total; end

  private

  # source://sidekiq-pro//lib/sidekiq/batch/status.rb#92
  def time_for(name); end
end

# source://sidekiq-pro//lib/sidekiq/batch.rb#72
Sidekiq::Batch::VALID_EVENTS = T.let(T.unsafe(nil), Array)

# source://sidekiq-pro//lib/sidekiq/batch/client.rb#4
module Sidekiq::BatchClient
  # The Sidekiq Batch client adds atomicity to batch definition:
  # all jobs created within the +jobs+ block are pushed into a
  # temporary array and then all flushed at once to Redis in a single
  # transaction.  This solves two problems:
  #
  # 1. We don't "half-create" a batch due to a networking issue
  # 2. We don't have a "completed" race condition when creating the jobs slower
  #    than we can process them.
  #
  # NB: creating very large numbers of jobs in one atomic block can be
  # dangerous -- it can spike Redis latency.  I generally recommend creating
  # blocks of jobs in parallel, 1,000 jobs per block, by creating an initial
  # set of jobs in the batch which reopen the batch and push those blocks.
  # It's not unusual for customers to have batches with 100,000+ jobs.
  #
  # source://sidekiq-pro//lib/sidekiq/batch/client.rb#21
  def flush(conn); end

  private

  # source://sidekiq-pro//lib/sidekiq/batch/client.rb#31
  def collected_payloads; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/batch/client.rb#44
  def defining_batch?; end

  # source://sidekiq-pro//lib/sidekiq/batch/client.rb#35
  def raw_push(payloads); end
end

# Allows enumeration of all Batches in Redis.
# Example:
#
#   Sidekiq::BatchSet.new.each do |status|
#     puts status.bid
#   end
#
# source://sidekiq-pro//lib/sidekiq/pro/api.rb#14
class Sidekiq::BatchSet
  include ::Enumerable

  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#23
  def each; end

  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#17
  def size; end
end

# source://sidekiq-pro//lib/sidekiq/pro/push.rb#93
class Sidekiq::Client
  include ::Sidekiq::BatchClient

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#45
  def initialize(*args, **kwargs); end

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#64
  def cancel!(jid); end

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#23
  def middleware(&block); end

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#101
  def push(item); end

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#131
  def push_bulk(items); end

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#31
  def redis_pool; end

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#31
  def redis_pool=(_arg0); end

  private

  # source://sidekiq/8.0.7/lib/sidekiq/client.rb#263
  def atomic_push(conn, payloads); end

  # source://sidekiq-pro//lib/sidekiq/batch/client.rb#35
  def raw_push(payloads); end

  class << self
    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#204
    def enqueue(klass, *args); end

    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#232
    def enqueue_in(interval, klass, *args); end

    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#211
    def enqueue_to(queue, klass, *args); end

    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#218
    def enqueue_to_in(queue, interval, klass, *args); end

    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#188
    def push(item); end

    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#192
    def push_bulk(*_arg0, **_arg1, &_arg2); end

    # source://sidekiq-pro//lib/sidekiq/pro/push.rb#94
    def reliable_push!; end

    # source://sidekiq/8.0.7/lib/sidekiq/client.rb#178
    def via(pool); end
  end
end

# source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#36
module Sidekiq::Component
  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#24
  def config; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#117
  def default_tag(dir = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#78
  def fire_event(event, options = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#74
  def handle_exception(ex, ctx = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#62
  def hostname; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#70
  def identity; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#99
  def inspect; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#50
  def logger; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#37
  def metrics(&block); end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#32
  def mono_ms; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#66
  def process_nonce; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#27
  def real_ms; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#54
  def redis(&block); end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#43
  def safe_thread(name, priority: T.unsafe(nil), &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#58
  def tid; end

  # source://sidekiq/8.0.7/lib/sidekiq/component.rb#36
  def watchdog(last_words); end
end

# Enable various reliability add-ons:
#
#   Sidekiq.configure_server do |config|
#     config.super_fetch!
#     config.reliable_scheduler!
#     # enable both
#     config.reliable!
#   end
#
# source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#5
class Sidekiq::Config
  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#62
  def initialize(options = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#246
  def average_scheduled_poll_interval=(interval); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#133
  def capsule(name); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#71
  def capsules; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#116
  def client_middleware; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#90
  def concurrency; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#86
  def concurrency=(val); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#237
  def death_handlers; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#128
  def default_capsule(&block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def dig(*args, **_arg1, &block); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#6
  def dogstatsd=(thing); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#257
  def error_handlers; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def fetch(*args, **_arg1, &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#222
  def freeze!; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#301
  def handle_exception(ex, ctx = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def has_key?(*args, **_arg1, &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#74
  def inspect; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def key?(*args, **_arg1, &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#275
  def logger; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#286
  def logger=(logger); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#214
  def lookup(name, default_class = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def merge!(*args, **_arg1, &block); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#16
  def metrics(&block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#158
  def new_redis_pool(size, name = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#269
  def on(event, &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#112
  def queues; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#108
  def queues=(val); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#180
  def redis; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#144
  def redis=(hash); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#164
  def redis_info; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#148
  def redis_pool; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#203
  def register(name, instance); end

  # source://sidekiq-pro//lib/sidekiq-pro.rb#61
  def reliable!; end

  # source://sidekiq-pro//lib/sidekiq-pro.rb#56
  def reliable_scheduler!; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#122
  def server_middleware; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#6
  def statsd=(thing); end

  # source://sidekiq-pro//lib/sidekiq-pro.rb#35
  def super_fetch!(options = T.unsafe(nil), &block); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#72
  def thread_priority; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#72
  def thread_priority=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#80
  def to_json(*_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#94
  def total_concurrency; end

  private

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#152
  def local_redis_pool; end

  # source://sidekiq/8.0.7/lib/sidekiq/config.rb#295
  def parameter_size(handler); end
end

# source://sidekiq-pro//lib/sidekiq/pro/job.rb#4
module Sidekiq::Job
  include ::Sidekiq::Job::Options

  mixes_in_class_methods ::Sidekiq::Job::Options::ClassMethods
  mixes_in_class_methods ::Sidekiq::Job::ClassMethods

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#163
  def _context; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#163
  def _context=(_arg0); end

  # source://sidekiq-pro//lib/sidekiq/pro/job.rb#7
  def batch; end

  # Returns the value of attribute bid.
  #
  # source://sidekiq-pro//lib/sidekiq/pro/job.rb#5
  def bid; end

  # Sets the attribute bid
  #
  # @param value the value to set the attribute bid to.
  #
  # source://sidekiq-pro//lib/sidekiq/pro/job.rb#5
  def bid=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#176
  def interrupted?; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#160
  def jid; end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#160
  def jid=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/job.rb#172
  def logger; end

  # Verify the job is still considered part of the batch.
  #
  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/pro/job.rb#12
  def valid_within_batch?; end

  class << self
    # source://sidekiq/8.0.7/lib/sidekiq/job.rb#165
    def included(base); end
  end
end

# source://sidekiq-pro//lib/sidekiq-pro.rb#14
Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq-pro.rb#13
Sidekiq::NAME = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq/pro/version.rb#2
module Sidekiq::Pro
  class << self
    # Track useful metrics within Sidekiq Pro and Sidekiq Enterprise.
    # Set to something that quacks like a ::Datadog::Statsd object from the dogstatsd-ruby gem.
    #
    # Datadog::Statsd is a big improvement over basic Statsd, it is recommended.
    # Configure it in your initializer like this:
    #
    #   Sidekiq::Pro.dogstatsd = ->{ ::Datadog::Statsd.new("metrics.acmecorp.com", 8125) }
    #
    # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#52
    def dogstatsd=(thing); end

    # source://sidekiq-pro//lib/sidekiq/pro/version.rb#6
    def gem_version; end

    # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#56
    def metrics(&block); end
  end
end

# Allows for real-time configuration updates to be published to all
# Sidekiq processes cluster-wise.  For example, pausing and unpausing
# queues is now instantaneous via this mechanism.
#
# Event listeners register their interest via #register and must
# supply a `notify(verb, payload)` method.
#
#   Sidekiq::Pro::Config.register(self)
#
# You can broadcast a config event via `publish`:
#
#   Sidekiq::Pro::Config.publish(:boom, { 'some' => 'info' })
#
# The `notify` method on all registered listeners on all Sidekiq processes
# will be called.
#
# NOTE: pubsub is not persistent so you need to ensure that your listeners
# can pull the current state of the system from Redis.
#
# source://sidekiq-pro//lib/sidekiq/pro/config.rb#26
class Sidekiq::Pro::ConfigListener
  include ::Sidekiq::Component

  # @return [ConfigListener] a new instance of ConfigListener
  #
  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#31
  def initialize(config); end

  # Takes a connection because it should be called as part of a larger
  # `multi` block to update Redis.
  #
  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#45
  def publish(conn, verb, payload); end

  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#39
  def register(handler); end

  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#54
  def start; end

  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#58
  def terminate(wait: T.unsafe(nil)); end

  private

  # NB: this method does not return
  #
  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#67
  def event_loop(pubsub); end

  # source://sidekiq-pro//lib/sidekiq/pro/config.rb#78
  def listen; end
end

# source://sidekiq-pro//lib/sidekiq/pro/config.rb#29
Sidekiq::Pro::ConfigListener::CHANNEL = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq/pro/version.rb#4
Sidekiq::Pro::MAJOR = T.let(T.unsafe(nil), Integer)

# source://sidekiq-pro//lib/sidekiq/pro/config.rb#4
class Sidekiq::Pro::Message < ::Struct
  # Returns the value of attribute db
  #
  # @return [Object] the current value of db
  def db; end

  # Sets the attribute db
  #
  # @param value [Object] the value to set the attribute db to.
  # @return [Object] the newly set value
  def db=(_); end

  # Returns the value of attribute payload
  #
  # @return [Object] the current value of payload
  def payload; end

  # Sets the attribute payload
  #
  # @param value [Object] the value to set the attribute payload to.
  # @return [Object] the newly set value
  def payload=(_); end

  # Returns the value of attribute verb
  #
  # @return [Object] the current value of verb
  def verb; end

  # Sets the attribute verb
  #
  # @param value [Object] the value to set the attribute verb to.
  # @return [Object] the newly set value
  def verb=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#60
module Sidekiq::Pro::Metrics; end

# Support for the improved Statsd API published by Datadog in the dogstatsd-ruby gem.
#
# source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#63
class Sidekiq::Pro::Metrics::Dogstatsd
  include ::Sidekiq::Component

  # If you are using plain vanilla Statsd, you can disable proprietary
  # extensions like so:
  # Sidekiq.configure_server { |c| c[:use_datadog_extensions] = false }
  #
  # @return [Dogstatsd] a new instance of Dogstatsd
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#70
  def initialize(config, statsd); end

  # @yield [_self]
  # @yieldparam _self [Sidekiq::Pro::Metrics::Dogstatsd] the object that the method was called on
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#133
  def batch(&block); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#99
  def count(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#91
  def decrement(name, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#107
  def distribution(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#111
  def distribution_time(name, value, opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#138
  def enabled?; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#95
  def gauge(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#103
  def histogram(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#87
  def increment(name, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#83
  def location; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#142
  def now; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#122
  def set(name, value, opts = T.unsafe(nil)); end

  # Returns the value of attribute statsd.
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#65
  def statsd; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#126
  def time(name, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#118
  def timing(name, value, opts = T.unsafe(nil)); end
end

# Support for no metrics
#
# source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#149
class Sidekiq::Pro::Metrics::Nil
  include ::Sidekiq::Component

  # @return [Nil] a new instance of Nil
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#151
  def initialize(config); end

  # @yield [_self]
  # @yieldparam _self [Sidekiq::Pro::Metrics::Nil] the object that the method was called on
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#191
  def batch; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#168
  def count(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#159
  def decrement(name, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#177
  def distribution(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#180
  def distribution_time(name, value, opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#155
  def enabled?; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#165
  def gauge(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#174
  def histogram(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#162
  def increment(name, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#171
  def set(name, value, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#187
  def time(name, opts = T.unsafe(nil)); end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#184
  def timing(name, value, opts = T.unsafe(nil)); end
end

# source://sidekiq-pro//lib/sidekiq/pro/scripting.rb#3
module Sidekiq::Pro::Scripting
  class << self
    # source://sidekiq-pro//lib/sidekiq/pro/scripting.rb#132
    def bootstrap(component); end

    # source://sidekiq-pro//lib/sidekiq/pro/scripting.rb#142
    def call(conn = T.unsafe(nil), name, keys, args, component); end
  end
end

# source://sidekiq-pro//lib/sidekiq/pro/scripting.rb#4
Sidekiq::Pro::Scripting::LUA_SCRIPTS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-pro//lib/sidekiq/pro/scripting.rb#130
Sidekiq::Pro::Scripting::SHAS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-pro//lib/sidekiq/pro/version.rb#3
Sidekiq::Pro::VERSION = T.let(T.unsafe(nil), String)

# source://sidekiq-pro//lib/sidekiq/pro/api.rb#46
class Sidekiq::Queue
  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#250
  def initialize(name = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#344
  def as_json(options = T.unsafe(nil)); end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#331
  def clear; end

  # Remove all jobs in the queue with the given class.
  # Accepts a String or Class but make sure to pass the fully
  # qualified Class name if you use a String.
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#69
  def delete_by_class(klass); end

  # Delete a job from the given queue.
  #
  # If the queue is being modified concurrently (e.g. another process is
  # pulling jobs from this queue), it is possible for the job to be "missed".
  # We iterate through the queue backwards to minimize this possibility.
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#52
  def delete_job(jid); end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#295
  def each; end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#325
  def find_job(jid); end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#273
  def latency; end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#247
  def name; end

  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#115
  def pause!; end

  # @return [Boolean]
  #
  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#132
  def paused?; end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#259
  def size; end

  # source://sidekiq-pro//lib/sidekiq/pro/api.rb#100
  def unpause!; end

  # source://sidekiq/8.0.7/lib/sidekiq/api.rb#331
  def 💣; end

  class << self
    # source://sidekiq/8.0.7/lib/sidekiq/api.rb#243
    def all; end
  end
end

# Reliable push is designed to handle transient network failures,
# which cause the client to fail to deliver jobs to Redis.  It is not
# designed to be a perfectly reliable client but rather an incremental
# improvement over the existing client which will just fail in the face
# of any networking error.
#
# Each client process has a local queue, used for storage if a network problem
# is detected.  Jobs are pushed to that queue if normal delivery fails.  If
# normal delivery succeeds, the local queue is drained of any stored jobs.
#
# The standard `Sidekiq::Client.push` API returns a JID if the push to redis succeeded
# or raises an error if there was a problem.  With reliable push activated,
# no Redis networking errors will be raised.
#
# source://sidekiq-pro//lib/sidekiq/pro/push.rb#23
module Sidekiq::ReliableClient
  # source://sidekiq-pro//lib/sidekiq/pro/push.rb#55
  def drain; end

  # source://sidekiq-pro//lib/sidekiq/pro/push.rb#36
  def local_queue; end

  # source://sidekiq-pro//lib/sidekiq/pro/push.rb#40
  def raw_push(payloads); end

  # source://sidekiq-pro//lib/sidekiq/pro/push.rb#81
  def save_locally(pool, payloads, ex); end
end

# Raised if we try to save more than `backup_limit` client payloads.
#
# source://sidekiq-pro//lib/sidekiq/pro/push.rb#25
class Sidekiq::ReliableClient::BufferFull < ::RuntimeError; end

# Provide implicit `metrics` accessor inside server middleware
# and server components.
#
# source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#30
module Sidekiq::ServerMiddleware
  # source://sidekiq/8.0.7/lib/sidekiq/middleware/modules.rb#7
  def config; end

  # source://sidekiq/8.0.7/lib/sidekiq/middleware/modules.rb#7
  def config=(_arg0); end

  # source://sidekiq/8.0.7/lib/sidekiq/middleware/modules.rb#12
  def logger; end

  # source://sidekiq-pro//lib/sidekiq/pro/metrics.rb#31
  def metrics(&block); end

  # source://sidekiq/8.0.7/lib/sidekiq/middleware/modules.rb#16
  def redis(&block); end

  # source://sidekiq/8.0.7/lib/sidekiq/middleware/modules.rb#8
  def redis_pool; end
end
